# ğŸ“š RV-II Emulator Documentation ğŸš€

Welcome to the **RV-II Emulator**! ğŸ‰ This is a minimalist, 2-bit RISC-V-inspired emulator written in C, designed to be modular, readable, and a stepping stone to a full RV32I emulator. Itâ€™s perfect for learning, experimenting, and building up to bigger systems! ğŸ˜„ This guide is for **users** running programs and **developers** extending the emulator. Letâ€™s get started! ğŸŒŠ

## ğŸŒŸ What is RV-II? ğŸŒŸ
RV-II is a tiny 2-bit processor emulator that:
- Runs programs from `in.txt` (or a command-line file) ğŸ“œ.
- Writes execution traces to `out.txt` ğŸ“.
- Uses an external `nand.+x` module for logic operations âš¡.
- Keeps things simple with arrays, no structs ğŸ§±.
- Sets the foundation for 4-bit, 8-bit, 16-bit, and 32-bit versions ğŸ“ˆ.

Itâ€™s a toy computer that does basic logic (NAND), moves data, jumps, and even supports self-modifying code! ğŸ¦˜

## ğŸ› ï¸ How It Works ğŸ› ï¸
RV-II has:
- **4 registers** (`r0-r3`), 2-bit each (0-3) ğŸ–ï¸.
- **16-byte memory** (`mem[0-15]`) for programs and data ğŸ’¾.
- **Program counter** (`pc`) to track execution ğŸ—ºï¸.
- **2-byte instructions** read from memory ğŸ“–.

### ğŸ’» Instruction Set
Each instruction is 2 bytes:
- **Byte 1** (`mem[pc]`): `opcode = (mem[pc] >> 2) & 0x3`, `op1 = mem[pc] & 0x3`.
- **Byte 2** (`mem[pc+1]`): `op2`, second operand.
- **PC Update**: `pc += 2` after each instruction, unless JUMP changes it.

| Opcode | Name  | Action                     | Description                              |
|--------|-------|----------------------------|------------------------------------------|
| 0      | NAND  | `reg[op1] = NAND(reg[op1], reg[op2])` | 2-bit NAND, store in `reg[op1]` ğŸ”§ |
| 1      | LOAD  | `reg[op1] = mem[op2] & 0x3` | Load 2 bits from `mem[op2]` to `reg[op1]` ğŸ“¥ |
| 2      | STORE | `mem[op2] = reg[op1] & 0x3` | Store `reg[op1]` to `mem[op2]` ğŸ“¤         |
| 3      | JUMP  | `pc = (reg[op1] & 0x7) * 2` | Jump to `reg[op1] * 2` (aligned address) ğŸ¦˜ |

- **NAND**: Calls `./+x/nand.+x 2 a b` â†’ `~(a & b) & 0x3`. The core of all logic! â¤ï¸
- **JUMP**: Takes lower 3 bits of `reg[op1]` (0-7), multiplies by 2 for even addresses (0, 2, ..., 14).
- **Self-Modifying Code**: STORE can overwrite instructions in memory, changing program behavior dynamically.

### ğŸ“‚ File I/O
- **Input**: Reads `in.txt` by default or a file via `./+x/rv-ii.+x myprog.txt` ğŸ“„.
  - Format: Space-separated bytes (e.g., `1 2 5 0`).
- **Output**: Writes trace to `out.txt` ğŸ“.
  - Format: `EXEC: opcode, op1, op2`, action, `PC, REG, MEM[0]`.
- **NAND Module**: `./+x/nand.+x` writes results to `temp.txt` ğŸ› ï¸.

### ğŸ›‘ Safety Features
- Halts if `pc >= 16` ğŸš«.
- Stops after 100 steps to catch infinite loops ğŸ”„.
- Validates `op2 < 4` for NAND to prevent invalid register access ğŸš¨.

## ğŸ® How to Use It (Users) ğŸ®
1. **Write a Program** âœï¸:
   - Create `in.txt` with bytes for instructions.
   - Example:
     ```
     1 2    // NAND r1, r2 (r1 = 3)
     5 0    // LOAD r1, mem[0] (r1 = 1)
     9 2    // STORE r1, mem[2] (mem[2] = 1, changes LOAD to NAND)
     13 0   // JUMP r1 (jumps based on r1)
     ```
2. **Compile** ğŸ› ï¸:
   ```bash
   gcc rv-ii.c -o /+x/rv-ii.+x
   gcc nand.c -o /+x/nand.+x
   ```
3. **Run** ğŸƒ:
   ```bash
   ./+x/rv-ii.+x in.txt
   ```
   Or default:
   ```bash
   ./+x/rv-ii.+x
   ```
4. **Check Output** ğŸ‘€:
   ```bash
   cat out.txt
   ```
   Example:
   ```
   EXEC: opcode=0, op1=1, op2=2
   NAND r1, r2 -> r1
   PC: 2, REG: [0,3,0,0], MEM[0]: 1
   ...
   Halted: Possible infinite loop
   ```

## ğŸ§‘â€ğŸ’» For Developers ğŸ§‘â€ğŸ’»
Ready to hack RV-II? Hereâ€™s the scoop! ğŸ”

### ğŸ“‚ File Structure
- **rv-ii.c**: Emulator core, handles execution and I/O ğŸ“Ÿ.
- **nand.c**: NAND logic, compiled to `./+x/nand.+x` âš™ï¸.
- **/+x/**: Stores executables (`rv-ii.+x`, `nand.+x`) ğŸ—‚ï¸.

### ğŸ”§ Key Functions
- **main()**: Initializes, loads program, runs execution loop.
- **nand_op()**: Calls `./+x/nand.+x`, reads `temp.txt`.

### ğŸ› ï¸ Extending RV-II
RV-II is the base for `rv-iv` (4-bit), `rv-viii` (8-bit), `rv-xvi` (16-bit), and `rv-xxxii` (RV32I). To extend:
- **Scale Up**: Increase register/memory size (e.g., 8 registers for rv-iv).
- **Add Instructions**: Build ADD, SUB, etc., using NAND.
- **Maintain Compatibility**: Ensure rv-ii programs run on higher-bit versions.
- **Reuse NAND**: `./+x/nand.+x` supports wider bits (e.g., `./+x/nand.+x 4 a b`).

### ğŸ› Debugging Tips
- **Trace out.txt**: Check `EXEC` logs for instruction details.
- **Test NAND**: `./+x/nand.+x 2 0 0` should output 3.
- **Validate in.txt**: Ensure bytes match `opcode = (byte >> 2) & 0x3`.
- **Check Loops**: JUMP with self-modifying code can change behavior (e.g., STORE to `mem[2]`).

## ğŸš€ Example Walkthrough ğŸš€
The example `in.txt`:
```
1 2    // NAND r1, r2
5 0    // LOAD r1, mem[0]
9 2    // STORE r1, mem[2]
13 0   // JUMP r1
```
- **Initial**: `reg=[0,0,0,0]`, `mem=[1,2,5,0,9,2,13,0,0,...]`.
- **PC=0**: NAND r1, r2 â†’ `r1=3`.
- **PC=2**: LOAD r1, mem[0] â†’ `r1=1`.
- **PC=4**: STORE r1, mem[2] â†’ `mem[2]=1` (changes LOAD to NAND).
- **PC=6**: JUMP r1 â†’ `PC=2` (r1=1).
- **PC=2**: NAND r1, r0 â†’ `r1=3` (due to modified `mem[2]=1`).
- **PC=4**: STORE r1, mem[2] â†’ `mem[2]=3`.
- **PC=6**: JUMP r1 â†’ `PC=6` (r1=3).
- **Loop**: Repeats JUMP at `PC=6`, halts after 100 steps.

This showcases **self-modifying code**, where STORE changes an instruction, altering the programâ€™s flow! ğŸ§™

## ğŸŒˆ Why RV-II? ğŸŒˆ
- **Modular**: External `nand.+x` for reusable logic.
- **Simple**: Arrays, no structs, easy to read.
- **Scalable**: Builds toward RV32I with compatibility.
- **Dynamic**: Supports self-modifying code for clever programs.

## ğŸ“¢ Next Steps
- Try new `in.txt` programs to explore self-modification ğŸ§ª.
- Move to `rv-iv.c` for 4-bit emulation ğŸ“ˆ.
- Report bugs or suggest features! ğŸ

Happy coding! ğŸˆ