# 📚 RV-II Emulator Documentation 🚀

Welcome to the **RV-II Emulator**! 🎉 This is a minimalist, 2-bit RISC-V-inspired emulator written in C, designed to be modular, readable, and a stepping stone to a full RV32I emulator. It’s perfect for learning, experimenting, and building up to bigger systems! 😄 This guide is for **users** running programs and **developers** extending the emulator. Let’s get started! 🌊

## 🌟 What is RV-II? 🌟
RV-II is a tiny 2-bit processor emulator that:
- Runs programs from `in.txt` (or a command-line file) 📜.
- Writes execution traces to `out.txt` 📝.
- Uses an external `nand.+x` module for logic operations ⚡.
- Keeps things simple with arrays, no structs 🧱.
- Sets the foundation for 4-bit, 8-bit, 16-bit, and 32-bit versions 📈.

It’s a toy computer that does basic logic (NAND), moves data, jumps, and even supports self-modifying code! 🦘

## 🛠️ How It Works 🛠️
RV-II has:
- **4 registers** (`r0-r3`), 2-bit each (0-3) 🖐️.
- **16-byte memory** (`mem[0-15]`) for programs and data 💾.
- **Program counter** (`pc`) to track execution 🗺️.
- **2-byte instructions** read from memory 📖.

### 💻 Instruction Set
Each instruction is 2 bytes:
- **Byte 1** (`mem[pc]`): `opcode = (mem[pc] >> 2) & 0x3`, `op1 = mem[pc] & 0x3`.
- **Byte 2** (`mem[pc+1]`): `op2`, second operand.
- **PC Update**: `pc += 2` after each instruction, unless JUMP changes it.

| Opcode | Name  | Action                     | Description                              |
|--------|-------|----------------------------|------------------------------------------|
| 0      | NAND  | `reg[op1] = NAND(reg[op1], reg[op2])` | 2-bit NAND, store in `reg[op1]` 🔧 |
| 1      | LOAD  | `reg[op1] = mem[op2] & 0x3` | Load 2 bits from `mem[op2]` to `reg[op1]` 📥 |
| 2      | STORE | `mem[op2] = reg[op1] & 0x3` | Store `reg[op1]` to `mem[op2]` 📤         |
| 3      | JUMP  | `pc = (reg[op1] & 0x7) * 2` | Jump to `reg[op1] * 2` (aligned address) 🦘 |

- **NAND**: Calls `./+x/nand.+x 2 a b` → `~(a & b) & 0x3`. The core of all logic! ❤️
- **JUMP**: Takes lower 3 bits of `reg[op1]` (0-7), multiplies by 2 for even addresses (0, 2, ..., 14).
- **Self-Modifying Code**: STORE can overwrite instructions in memory, changing program behavior dynamically.

### 📂 File I/O
- **Input**: Reads `in.txt` by default or a file via `./+x/rv-ii.+x myprog.txt` 📄.
  - Format: Space-separated bytes (e.g., `1 2 5 0`).
- **Output**: Writes trace to `out.txt` 📝.
  - Format: `EXEC: opcode, op1, op2`, action, `PC, REG, MEM[0]`.
- **NAND Module**: `./+x/nand.+x` writes results to `temp.txt` 🛠️.

### 🛑 Safety Features
- Halts if `pc >= 16` 🚫.
- Stops after 100 steps to catch infinite loops 🔄.
- Validates `op2 < 4` for NAND to prevent invalid register access 🚨.

## 🎮 How to Use It (Users) 🎮
1. **Write a Program** ✍️:
   - Create `in.txt` with bytes for instructions.
   - Example:
     ```
     1 2    // NAND r1, r2 (r1 = 3)
     5 0    // LOAD r1, mem[0] (r1 = 1)
     9 2    // STORE r1, mem[2] (mem[2] = 1, changes LOAD to NAND)
     13 0   // JUMP r1 (jumps based on r1)
     ```
2. **Compile** 🛠️:
   ```bash
   gcc rv-ii.c -o /+x/rv-ii.+x
   gcc nand.c -o /+x/nand.+x
   ```
3. **Run** 🏃:
   ```bash
   ./+x/rv-ii.+x in.txt
   ```
   Or default:
   ```bash
   ./+x/rv-ii.+x
   ```
4. **Check Output** 👀:
   ```bash
   cat out.txt
   ```
   Example:
   ```
   EXEC: opcode=0, op1=1, op2=2
   NAND r1, r2 -> r1
   PC: 2, REG: [0,3,0,0], MEM[0]: 1
   ...
   Halted: Possible infinite loop
   ```

## 🧑‍💻 For Developers 🧑‍💻
Ready to hack RV-II? Here’s the scoop! 🔍

### 📂 File Structure
- **rv-ii.c**: Emulator core, handles execution and I/O 📟.
- **nand.c**: NAND logic, compiled to `./+x/nand.+x` ⚙️.
- **/+x/**: Stores executables (`rv-ii.+x`, `nand.+x`) 🗂️.

### 🔧 Key Functions
- **main()**: Initializes, loads program, runs execution loop.
- **nand_op()**: Calls `./+x/nand.+x`, reads `temp.txt`.

### 🛠️ Extending RV-II
RV-II is the base for `rv-iv` (4-bit), `rv-viii` (8-bit), `rv-xvi` (16-bit), and `rv-xxxii` (RV32I). To extend:
- **Scale Up**: Increase register/memory size (e.g., 8 registers for rv-iv).
- **Add Instructions**: Build ADD, SUB, etc., using NAND.
- **Maintain Compatibility**: Ensure rv-ii programs run on higher-bit versions.
- **Reuse NAND**: `./+x/nand.+x` supports wider bits (e.g., `./+x/nand.+x 4 a b`).

### 🐛 Debugging Tips
- **Trace out.txt**: Check `EXEC` logs for instruction details.
- **Test NAND**: `./+x/nand.+x 2 0 0` should output 3.
- **Validate in.txt**: Ensure bytes match `opcode = (byte >> 2) & 0x3`.
- **Check Loops**: JUMP with self-modifying code can change behavior (e.g., STORE to `mem[2]`).

## 🚀 Example Walkthrough 🚀
The example `in.txt`:
```
1 2    // NAND r1, r2
5 0    // LOAD r1, mem[0]
9 2    // STORE r1, mem[2]
13 0   // JUMP r1
```
- **Initial**: `reg=[0,0,0,0]`, `mem=[1,2,5,0,9,2,13,0,0,...]`.
- **PC=0**: NAND r1, r2 → `r1=3`.
- **PC=2**: LOAD r1, mem[0] → `r1=1`.
- **PC=4**: STORE r1, mem[2] → `mem[2]=1` (changes LOAD to NAND).
- **PC=6**: JUMP r1 → `PC=2` (r1=1).
- **PC=2**: NAND r1, r0 → `r1=3` (due to modified `mem[2]=1`).
- **PC=4**: STORE r1, mem[2] → `mem[2]=3`.
- **PC=6**: JUMP r1 → `PC=6` (r1=3).
- **Loop**: Repeats JUMP at `PC=6`, halts after 100 steps.

This showcases **self-modifying code**, where STORE changes an instruction, altering the program’s flow! 🧙

## 🌈 Why RV-II? 🌈
- **Modular**: External `nand.+x` for reusable logic.
- **Simple**: Arrays, no structs, easy to read.
- **Scalable**: Builds toward RV32I with compatibility.
- **Dynamic**: Supports self-modifying code for clever programs.

## 📢 Next Steps
- Try new `in.txt` programs to explore self-modification 🧪.
- Move to `rv-iv.c` for 4-bit emulation 📈.
- Report bugs or suggest features! 🐞

Happy coding! 🎈