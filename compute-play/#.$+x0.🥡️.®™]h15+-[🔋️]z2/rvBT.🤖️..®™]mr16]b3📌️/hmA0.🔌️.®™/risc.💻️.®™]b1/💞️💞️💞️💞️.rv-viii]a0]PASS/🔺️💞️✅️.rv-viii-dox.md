📚 RV-VIII Emulator Documentation 🚀
Welcome to the RV-VIII Emulator! 🎉 This 8-bit RISC-V-inspired emulator builds on RV-IV, scaling up for larger values and programs while keeping simplicity and modularity. It’s a step toward RV32I, perfect for learning and experimentation! 😄 This guide is for users running programs and developers extending the system. Let’s dive in! 🌊
🌟 What is RV-VIII? 🌟
RV-VIII is an 8-bit processor emulator that:

Runs programs from in.txt (or a specified file) 📜.
Writes execution traces to out.txt 📝.
Uses ./+x/nand.+x for 8-bit NAND operations ⚡.
Keeps code simple with arrays, no structs 🧱.
Supports RV-II/IV compatibility and self-modifying code.
Paves the way for 16-bit and 32-bit emulators 📈.

It’s a mini computer for logic, data movement, and dynamic program changes! 🦘
🛠️ How It Works 🛠️
RV-VIII features:

16 registers (r0-r15), 8-bit each (0-255) 🖐️.
256-byte memory (mem[0-255]) for programs and data 💾.
Program counter (pc) to track execution 🗺️.
2-byte instructions fetched from memory 📖.

💻 Instruction Set
Each instruction is 2 bytes:

Byte 1 (mem[pc]): opcode = (mem[pc] >> 6) & 0x3, op1 = mem[pc] & 0xF.
Byte 2 (mem[pc+1]): op2, second operand (0-255).
PC Update: pc += 2, unless JUMP overrides.




Opcode
Name
Action
Description



0
NAND
reg[op1] = NAND(reg[op1], reg[op2])
8-bit NAND, store in reg[op1] 🔧


1
LOAD
reg[op1] = mem[op2] & 0xFF
Load 8 bits from mem[op2] to reg[op1] 📥


2
STORE
mem[op2] = reg[op1] & 0xFF
Store reg[op1] to mem[op2] 📤


3
JUMP
pc = (reg[op1] & 0x7F) * 2
Jump to reg[op1] * 2 (aligned address) 🦘



NAND: Calls ./+x/nand.+x 8 a b → ~(a & b) & 0xFF. Core logic operation! ❤️
JUMP: Uses lower 7 bits of reg[op1] (0-127), multiplies by 2 for even addresses (0, 2, ..., 254).
Self-Modifying Code: STORE can overwrite instructions, enabling dynamic behavior.

📂 File I/O

Input: Reads in.txt or a file via ./+x/rv-viii.+x myprog.txt 📄.
Format: Space-separated bytes (e.g., 1 2 65 0).


Output: Writes trace to out.txt 📝.
Format: EXEC: opcode, op1, op2, action, PC, REG, MEM[0].


NAND Module: ./+x/nand.+x writes results to temp.txt 🛠️.

🛑 Safety Features

Halts if pc >= 256 (“Halted: PC out of bounds”) 🚫.
Stops after 100 steps (“Halted: Possible infinite loop”) 🔄.
Checks op2 < 16 for NAND to avoid invalid registers 🚨.

🎮 How to Use It (Users) 🎮

Write a Program ✍️:
Create in.txt with instruction bytes.
Example:1 2    // NAND r1, r2 (r1 = 255)
65 0   // LOAD r1, mem[0] (r1 = 1)
129 2  // STORE r1, mem[2] (mem[2] = 1, changes LOAD to NAND)
193 0  // JUMP r1 (jumps based on r1)




Compile 🛠️:gcc rv-viii.c -o /+x/rv-viii.+x
gcc nand.c -o /+x/nand.+x


Run 🏃:./+x/rv-viii.+x in.txt

Or default:./+x/rv-viii.+x


Check Output 👀:cat out.txt

Example:EXEC: opcode=0, op1=1, op2=2
NAND r1, r2 -> r1
PC: 2, REG: [0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0], MEM[0]: 1
...
Halted: PC out of bounds



🧑‍💻 For Developers 🧑‍💻
Ready to hack RV-VIII? Here’s the lowdown! 🔍
📂 File Structure

rv-viii.c: Emulator core, handles execution and I/O 📟.
nand.c: NAND logic, compiled to ./+x/nand.+x ⚙️.
/+x/: Stores executables (rv-viii.+x, nand.+x) 🗂️.

🔧 Key Functions

main(): Initializes registers/memory, loads program, runs loop.
nand_op(): Calls ./+x/nand.+x, reads temp.txt.

🛠️ Extending RV-VIII
RV-VIII is a stepping stone to rv-xvi (16-bit) and rv-xxxii (RV32I). To extend:

Scale Up: Increase registers/memory (e.g., 32 registers for RV32I).
Add Instructions: Implement ADD, SUB, etc., via NAND.
Compatibility: Ensure RV-II/IV/VIII programs run (mask to 2/4/8 bits).
Reuse NAND: ./+x/nand.+x supports wider bits (e.g., ./+x/nand.+x 16 a b).

🐛 Debugging Tips

Trace out.txt: Verify EXEC logs for opcodes/operands.
Test NAND: ./+x/nand.+x 8 0 0 should output 255.
Validate in.txt: Check opcode = (byte >> 6) & 0x3, op1 = byte & 0xF.
Self-Modification: STORE to instruction addresses (e.g., mem[2]) changes behavior.

🚀 Example Walkthrough 🚀
For in.txt:
1 2    // NAND r1, r2
65 0   // LOAD r1, mem[0]
129 2  // STORE r1, mem[2]
193 0  // JUMP r1


Initial: reg=[0,0,0,...], mem=[1,2,65,0,129,2,193,0,0,...].
PC=0: NAND r1, r2 → r1=255.
PC=2: LOAD r1, mem[0] → r1=1.
PC=4: STORE r1, mem[2] → mem[2]=1 (LOAD becomes NAND).
PC=6: JUMP r1 → PC=2 (r1=1).
PC=2: NAND r1, r0 → r1=255 (due to mem[2]=1).
PC=4: STORE r1, mem[2] → mem[2]=255.
PC=6: JUMP r1 → PC=254 (r1=255 & 0x7F = 127).
PC=254: NAND r0, r0 → r0=255.
PC=256: Halts with “Halted: PC out of bounds”.

This showcases self-modifying code, dynamically altering program flow! 🧙
🌈 Why RV-VIII? 🌈

Modular: Reuses nand.+x for logic.
Simple: Arrays keep code clear.
Scalable: Steps toward RV32I with RV-II/IV compatibility.
Dynamic: Self-modifying code enables creative programs.

📢 Next Steps

Test new in.txt programs to explore self-modification 🧪.
Move to rv-xvi.c for 16-bit emulation 📈.
Share bugs or feature ideas! 🐞

Happy emulating! 🎈📚 RV-VIII Emulator Documentation 🚀
Welcome to the RV-VIII Emulator! 🎉 This 8-bit RISC-V-inspired emulator builds on RV-IV, scaling up for larger values and programs while keeping simplicity and modularity. It’s a step toward RV32I, perfect for learning and experimentation! 😄 This guide is for users running programs and developers extending the system. Let’s dive in! 🌊
🌟 What is RV-VIII? 🌟
RV-VIII is an 8-bit processor emulator that:

Runs programs from in.txt (or a specified file) 📜.
Writes execution traces to out.txt 📝.
Uses ./+x/nand.+x for 8-bit NAND operations ⚡.
Keeps code simple with arrays, no structs 🧱.
Supports RV-II/IV compatibility and self-modifying code.
Paves the way for 16-bit and 32-bit emulators 📈.

It’s a mini computer for logic, data movement, and dynamic program changes! 🦘
🛠️ How It Works 🛠️
RV-VIII features:

16 registers (r0-r15), 8-bit each (0-255) 🖐️.
256-byte memory (mem[0-255]) for programs and data 💾.
Program counter (pc) to track execution 🗺️.
2-byte instructions fetched from memory 📖.

💻 Instruction Set
Each instruction is 2 bytes:

Byte 1 (mem[pc]): opcode = (mem[pc] >> 6) & 0x3, op1 = mem[pc] & 0xF.
Byte 2 (mem[pc+1]): op2, second operand (0-255).
PC Update: pc += 2, unless JUMP overrides.




Opcode
Name
Action
Description



0
NAND
reg[op1] = NAND(reg[op1], reg[op2])
8-bit NAND, store in reg[op1] 🔧


1
LOAD
reg[op1] = mem[op2] & 0xFF
Load 8 bits from mem[op2] to reg[op1] 📥


2
STORE
mem[op2] = reg[op1] & 0xFF
Store reg[op1] to mem[op2] 📤


3
JUMP
pc = (reg[op1] & 0x7F) * 2
Jump to reg[op1] * 2 (aligned address) 🦘



NAND: Calls ./+x/nand.+x 8 a b → ~(a & b) & 0xFF. Core logic operation! ❤️
JUMP: Uses lower 7 bits of reg[op1] (0-127), multiplies by 2 for even addresses (0, 2, ..., 254).
Self-Modifying Code: STORE can overwrite instructions, enabling dynamic behavior.

📂 File I/O

Input: Reads in.txt or a file via ./+x/rv-viii.+x myprog.txt 📄.
Format: Space-separated bytes (e.g., 1 2 65 0).


Output: Writes trace to out.txt 📝.
Format: EXEC: opcode, op1, op2, action, PC, REG, MEM[0].


NAND Module: ./+x/nand.+x writes results to temp.txt 🛠️.

🛑 Safety Features

Halts if pc >= 256 (“Halted: PC out of bounds”) 🚫.
Stops after 100 steps (“Halted: Possible infinite loop”) 🔄.
Checks op2 < 16 for NAND to avoid invalid registers 🚨.

🎮 How to Use It (Users) 🎮

Write a Program ✍️:
Create in.txt with instruction bytes.
Example:1 2    // NAND r1, r2 (r1 = 255)
65 0   // LOAD r1, mem[0] (r1 = 1)
129 2  // STORE r1, mem[2] (mem[2] = 1, changes LOAD to NAND)
193 0  // JUMP r1 (jumps based on r1)




Compile 🛠️:gcc rv-viii.c -o /+x/rv-viii.+x
gcc nand.c -o /+x/nand.+x


Run 🏃:./+x/rv-viii.+x in.txt

Or default:./+x/rv-viii.+x


Check Output 👀:cat out.txt

Example:EXEC: opcode=0, op1=1, op2=2
NAND r1, r2 -> r1
PC: 2, REG: [0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0], MEM[0]: 1
...
Halted: PC out of bounds



🧑‍💻 For Developers 🧑‍💻
Ready to hack RV-VIII? Here’s the lowdown! 🔍
📂 File Structure

rv-viii.c: Emulator core, handles execution and I/O 📟.
nand.c: NAND logic, compiled to ./+x/nand.+x ⚙️.
/+x/: Stores executables (rv-viii.+x, nand.+x) 🗂️.

🔧 Key Functions

main(): Initializes registers/memory, loads program, runs loop.
nand_op(): Calls ./+x/nand.+x, reads temp.txt.

🛠️ Extending RV-VIII
RV-VIII is a stepping stone to rv-xvi (16-bit) and rv-xxxii (RV32I). To extend:

Scale Up: Increase registers/memory (e.g., 32 registers for RV32I).
Add Instructions: Implement ADD, SUB, etc., via NAND.
Compatibility: Ensure RV-II/IV/VIII programs run (mask to 2/4/8 bits).
Reuse NAND: ./+x/nand.+x supports wider bits (e.g., ./+x/nand.+x 16 a b).

🐛 Debugging Tips

Trace out.txt: Verify EXEC logs for opcodes/operands.
Test NAND: ./+x/nand.+x 8 0 0 should output 255.
Validate in.txt: Check opcode = (byte >> 6) & 0x3, op1 = byte & 0xF.
Self-Modification: STORE to instruction addresses (e.g., mem[2]) changes behavior.

🚀 Example Walkthrough 🚀
For in.txt:
1 2    // NAND r1, r2
65 0   // LOAD r1, mem[0]
129 2  // STORE r1, mem[2]
193 0  // JUMP r1


Initial: reg=[0,0,0,...], mem=[1,2,65,0,129,2,193,0,0,...].
PC=0: NAND r1, r2 → r1=255.
PC=2: LOAD r1, mem[0] → r1=1.
PC=4: STORE r1, mem[2] → mem[2]=1 (LOAD becomes NAND).
PC=6: JUMP r1 → PC=2 (r1=1).
PC=2: NAND r1, r0 → r1=255 (due to mem[2]=1).
PC=4: STORE r1, mem[2] → mem[2]=255.
PC=6: JUMP r1 → PC=254 (r1=255 & 0x7F = 127).
PC=254: NAND r0, r0 → r0=255.
PC=256: Halts with “Halted: PC out of bounds”.

This showcases self-modifying code, dynamically altering program flow! 🧙
🌈 Why RV-VIII? 🌈

Modular: Reuses nand.+x for logic.
Simple: Arrays keep code clear.
Scalable: Steps toward RV32I with RV-II/IV compatibility.
Dynamic: Self-modifying code enables creative programs.

📢 Next Steps

Test new in.txt programs to explore self-modification 🧪.
Move to rv-xvi.c for 16-bit emulation 📈.
Share bugs or feature ideas! 🐞

Happy emulating! 🎈
