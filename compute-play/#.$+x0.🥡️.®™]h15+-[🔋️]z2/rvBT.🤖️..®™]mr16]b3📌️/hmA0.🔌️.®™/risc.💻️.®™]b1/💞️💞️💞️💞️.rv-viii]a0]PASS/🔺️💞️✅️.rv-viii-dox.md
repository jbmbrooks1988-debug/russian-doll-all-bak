ğŸ“š RV-VIII Emulator Documentation ğŸš€
Welcome to the RV-VIII Emulator! ğŸ‰ This 8-bit RISC-V-inspired emulator builds on RV-IV, scaling up for larger values and programs while keeping simplicity and modularity. Itâ€™s a step toward RV32I, perfect for learning and experimentation! ğŸ˜„ This guide is for users running programs and developers extending the system. Letâ€™s dive in! ğŸŒŠ
ğŸŒŸ What is RV-VIII? ğŸŒŸ
RV-VIII is an 8-bit processor emulator that:

Runs programs from in.txt (or a specified file) ğŸ“œ.
Writes execution traces to out.txt ğŸ“.
Uses ./+x/nand.+x for 8-bit NAND operations âš¡.
Keeps code simple with arrays, no structs ğŸ§±.
Supports RV-II/IV compatibility and self-modifying code.
Paves the way for 16-bit and 32-bit emulators ğŸ“ˆ.

Itâ€™s a mini computer for logic, data movement, and dynamic program changes! ğŸ¦˜
ğŸ› ï¸ How It Works ğŸ› ï¸
RV-VIII features:

16 registers (r0-r15), 8-bit each (0-255) ğŸ–ï¸.
256-byte memory (mem[0-255]) for programs and data ğŸ’¾.
Program counter (pc) to track execution ğŸ—ºï¸.
2-byte instructions fetched from memory ğŸ“–.

ğŸ’» Instruction Set
Each instruction is 2 bytes:

Byte 1 (mem[pc]): opcode = (mem[pc] >> 6) & 0x3, op1 = mem[pc] & 0xF.
Byte 2 (mem[pc+1]): op2, second operand (0-255).
PC Update: pc += 2, unless JUMP overrides.




Opcode
Name
Action
Description



0
NAND
reg[op1] = NAND(reg[op1], reg[op2])
8-bit NAND, store in reg[op1] ğŸ”§


1
LOAD
reg[op1] = mem[op2] & 0xFF
Load 8 bits from mem[op2] to reg[op1] ğŸ“¥


2
STORE
mem[op2] = reg[op1] & 0xFF
Store reg[op1] to mem[op2] ğŸ“¤


3
JUMP
pc = (reg[op1] & 0x7F) * 2
Jump to reg[op1] * 2 (aligned address) ğŸ¦˜



NAND: Calls ./+x/nand.+x 8 a b â†’ ~(a & b) & 0xFF. Core logic operation! â¤ï¸
JUMP: Uses lower 7 bits of reg[op1] (0-127), multiplies by 2 for even addresses (0, 2, ..., 254).
Self-Modifying Code: STORE can overwrite instructions, enabling dynamic behavior.

ğŸ“‚ File I/O

Input: Reads in.txt or a file via ./+x/rv-viii.+x myprog.txt ğŸ“„.
Format: Space-separated bytes (e.g., 1 2 65 0).


Output: Writes trace to out.txt ğŸ“.
Format: EXEC: opcode, op1, op2, action, PC, REG, MEM[0].


NAND Module: ./+x/nand.+x writes results to temp.txt ğŸ› ï¸.

ğŸ›‘ Safety Features

Halts if pc >= 256 (â€œHalted: PC out of boundsâ€) ğŸš«.
Stops after 100 steps (â€œHalted: Possible infinite loopâ€) ğŸ”„.
Checks op2 < 16 for NAND to avoid invalid registers ğŸš¨.

ğŸ® How to Use It (Users) ğŸ®

Write a Program âœï¸:
Create in.txt with instruction bytes.
Example:1 2    // NAND r1, r2 (r1 = 255)
65 0   // LOAD r1, mem[0] (r1 = 1)
129 2  // STORE r1, mem[2] (mem[2] = 1, changes LOAD to NAND)
193 0  // JUMP r1 (jumps based on r1)




Compile ğŸ› ï¸:gcc rv-viii.c -o /+x/rv-viii.+x
gcc nand.c -o /+x/nand.+x


Run ğŸƒ:./+x/rv-viii.+x in.txt

Or default:./+x/rv-viii.+x


Check Output ğŸ‘€:cat out.txt

Example:EXEC: opcode=0, op1=1, op2=2
NAND r1, r2 -> r1
PC: 2, REG: [0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0], MEM[0]: 1
...
Halted: PC out of bounds



ğŸ§‘â€ğŸ’» For Developers ğŸ§‘â€ğŸ’»
Ready to hack RV-VIII? Hereâ€™s the lowdown! ğŸ”
ğŸ“‚ File Structure

rv-viii.c: Emulator core, handles execution and I/O ğŸ“Ÿ.
nand.c: NAND logic, compiled to ./+x/nand.+x âš™ï¸.
/+x/: Stores executables (rv-viii.+x, nand.+x) ğŸ—‚ï¸.

ğŸ”§ Key Functions

main(): Initializes registers/memory, loads program, runs loop.
nand_op(): Calls ./+x/nand.+x, reads temp.txt.

ğŸ› ï¸ Extending RV-VIII
RV-VIII is a stepping stone to rv-xvi (16-bit) and rv-xxxii (RV32I). To extend:

Scale Up: Increase registers/memory (e.g., 32 registers for RV32I).
Add Instructions: Implement ADD, SUB, etc., via NAND.
Compatibility: Ensure RV-II/IV/VIII programs run (mask to 2/4/8 bits).
Reuse NAND: ./+x/nand.+x supports wider bits (e.g., ./+x/nand.+x 16 a b).

ğŸ› Debugging Tips

Trace out.txt: Verify EXEC logs for opcodes/operands.
Test NAND: ./+x/nand.+x 8 0 0 should output 255.
Validate in.txt: Check opcode = (byte >> 6) & 0x3, op1 = byte & 0xF.
Self-Modification: STORE to instruction addresses (e.g., mem[2]) changes behavior.

ğŸš€ Example Walkthrough ğŸš€
For in.txt:
1 2    // NAND r1, r2
65 0   // LOAD r1, mem[0]
129 2  // STORE r1, mem[2]
193 0  // JUMP r1


Initial: reg=[0,0,0,...], mem=[1,2,65,0,129,2,193,0,0,...].
PC=0: NAND r1, r2 â†’ r1=255.
PC=2: LOAD r1, mem[0] â†’ r1=1.
PC=4: STORE r1, mem[2] â†’ mem[2]=1 (LOAD becomes NAND).
PC=6: JUMP r1 â†’ PC=2 (r1=1).
PC=2: NAND r1, r0 â†’ r1=255 (due to mem[2]=1).
PC=4: STORE r1, mem[2] â†’ mem[2]=255.
PC=6: JUMP r1 â†’ PC=254 (r1=255 & 0x7F = 127).
PC=254: NAND r0, r0 â†’ r0=255.
PC=256: Halts with â€œHalted: PC out of boundsâ€.

This showcases self-modifying code, dynamically altering program flow! ğŸ§™
ğŸŒˆ Why RV-VIII? ğŸŒˆ

Modular: Reuses nand.+x for logic.
Simple: Arrays keep code clear.
Scalable: Steps toward RV32I with RV-II/IV compatibility.
Dynamic: Self-modifying code enables creative programs.

ğŸ“¢ Next Steps

Test new in.txt programs to explore self-modification ğŸ§ª.
Move to rv-xvi.c for 16-bit emulation ğŸ“ˆ.
Share bugs or feature ideas! ğŸ

Happy emulating! ğŸˆğŸ“š RV-VIII Emulator Documentation ğŸš€
Welcome to the RV-VIII Emulator! ğŸ‰ This 8-bit RISC-V-inspired emulator builds on RV-IV, scaling up for larger values and programs while keeping simplicity and modularity. Itâ€™s a step toward RV32I, perfect for learning and experimentation! ğŸ˜„ This guide is for users running programs and developers extending the system. Letâ€™s dive in! ğŸŒŠ
ğŸŒŸ What is RV-VIII? ğŸŒŸ
RV-VIII is an 8-bit processor emulator that:

Runs programs from in.txt (or a specified file) ğŸ“œ.
Writes execution traces to out.txt ğŸ“.
Uses ./+x/nand.+x for 8-bit NAND operations âš¡.
Keeps code simple with arrays, no structs ğŸ§±.
Supports RV-II/IV compatibility and self-modifying code.
Paves the way for 16-bit and 32-bit emulators ğŸ“ˆ.

Itâ€™s a mini computer for logic, data movement, and dynamic program changes! ğŸ¦˜
ğŸ› ï¸ How It Works ğŸ› ï¸
RV-VIII features:

16 registers (r0-r15), 8-bit each (0-255) ğŸ–ï¸.
256-byte memory (mem[0-255]) for programs and data ğŸ’¾.
Program counter (pc) to track execution ğŸ—ºï¸.
2-byte instructions fetched from memory ğŸ“–.

ğŸ’» Instruction Set
Each instruction is 2 bytes:

Byte 1 (mem[pc]): opcode = (mem[pc] >> 6) & 0x3, op1 = mem[pc] & 0xF.
Byte 2 (mem[pc+1]): op2, second operand (0-255).
PC Update: pc += 2, unless JUMP overrides.




Opcode
Name
Action
Description



0
NAND
reg[op1] = NAND(reg[op1], reg[op2])
8-bit NAND, store in reg[op1] ğŸ”§


1
LOAD
reg[op1] = mem[op2] & 0xFF
Load 8 bits from mem[op2] to reg[op1] ğŸ“¥


2
STORE
mem[op2] = reg[op1] & 0xFF
Store reg[op1] to mem[op2] ğŸ“¤


3
JUMP
pc = (reg[op1] & 0x7F) * 2
Jump to reg[op1] * 2 (aligned address) ğŸ¦˜



NAND: Calls ./+x/nand.+x 8 a b â†’ ~(a & b) & 0xFF. Core logic operation! â¤ï¸
JUMP: Uses lower 7 bits of reg[op1] (0-127), multiplies by 2 for even addresses (0, 2, ..., 254).
Self-Modifying Code: STORE can overwrite instructions, enabling dynamic behavior.

ğŸ“‚ File I/O

Input: Reads in.txt or a file via ./+x/rv-viii.+x myprog.txt ğŸ“„.
Format: Space-separated bytes (e.g., 1 2 65 0).


Output: Writes trace to out.txt ğŸ“.
Format: EXEC: opcode, op1, op2, action, PC, REG, MEM[0].


NAND Module: ./+x/nand.+x writes results to temp.txt ğŸ› ï¸.

ğŸ›‘ Safety Features

Halts if pc >= 256 (â€œHalted: PC out of boundsâ€) ğŸš«.
Stops after 100 steps (â€œHalted: Possible infinite loopâ€) ğŸ”„.
Checks op2 < 16 for NAND to avoid invalid registers ğŸš¨.

ğŸ® How to Use It (Users) ğŸ®

Write a Program âœï¸:
Create in.txt with instruction bytes.
Example:1 2    // NAND r1, r2 (r1 = 255)
65 0   // LOAD r1, mem[0] (r1 = 1)
129 2  // STORE r1, mem[2] (mem[2] = 1, changes LOAD to NAND)
193 0  // JUMP r1 (jumps based on r1)




Compile ğŸ› ï¸:gcc rv-viii.c -o /+x/rv-viii.+x
gcc nand.c -o /+x/nand.+x


Run ğŸƒ:./+x/rv-viii.+x in.txt

Or default:./+x/rv-viii.+x


Check Output ğŸ‘€:cat out.txt

Example:EXEC: opcode=0, op1=1, op2=2
NAND r1, r2 -> r1
PC: 2, REG: [0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0], MEM[0]: 1
...
Halted: PC out of bounds



ğŸ§‘â€ğŸ’» For Developers ğŸ§‘â€ğŸ’»
Ready to hack RV-VIII? Hereâ€™s the lowdown! ğŸ”
ğŸ“‚ File Structure

rv-viii.c: Emulator core, handles execution and I/O ğŸ“Ÿ.
nand.c: NAND logic, compiled to ./+x/nand.+x âš™ï¸.
/+x/: Stores executables (rv-viii.+x, nand.+x) ğŸ—‚ï¸.

ğŸ”§ Key Functions

main(): Initializes registers/memory, loads program, runs loop.
nand_op(): Calls ./+x/nand.+x, reads temp.txt.

ğŸ› ï¸ Extending RV-VIII
RV-VIII is a stepping stone to rv-xvi (16-bit) and rv-xxxii (RV32I). To extend:

Scale Up: Increase registers/memory (e.g., 32 registers for RV32I).
Add Instructions: Implement ADD, SUB, etc., via NAND.
Compatibility: Ensure RV-II/IV/VIII programs run (mask to 2/4/8 bits).
Reuse NAND: ./+x/nand.+x supports wider bits (e.g., ./+x/nand.+x 16 a b).

ğŸ› Debugging Tips

Trace out.txt: Verify EXEC logs for opcodes/operands.
Test NAND: ./+x/nand.+x 8 0 0 should output 255.
Validate in.txt: Check opcode = (byte >> 6) & 0x3, op1 = byte & 0xF.
Self-Modification: STORE to instruction addresses (e.g., mem[2]) changes behavior.

ğŸš€ Example Walkthrough ğŸš€
For in.txt:
1 2    // NAND r1, r2
65 0   // LOAD r1, mem[0]
129 2  // STORE r1, mem[2]
193 0  // JUMP r1


Initial: reg=[0,0,0,...], mem=[1,2,65,0,129,2,193,0,0,...].
PC=0: NAND r1, r2 â†’ r1=255.
PC=2: LOAD r1, mem[0] â†’ r1=1.
PC=4: STORE r1, mem[2] â†’ mem[2]=1 (LOAD becomes NAND).
PC=6: JUMP r1 â†’ PC=2 (r1=1).
PC=2: NAND r1, r0 â†’ r1=255 (due to mem[2]=1).
PC=4: STORE r1, mem[2] â†’ mem[2]=255.
PC=6: JUMP r1 â†’ PC=254 (r1=255 & 0x7F = 127).
PC=254: NAND r0, r0 â†’ r0=255.
PC=256: Halts with â€œHalted: PC out of boundsâ€.

This showcases self-modifying code, dynamically altering program flow! ğŸ§™
ğŸŒˆ Why RV-VIII? ğŸŒˆ

Modular: Reuses nand.+x for logic.
Simple: Arrays keep code clear.
Scalable: Steps toward RV32I with RV-II/IV compatibility.
Dynamic: Self-modifying code enables creative programs.

ğŸ“¢ Next Steps

Test new in.txt programs to explore self-modification ğŸ§ª.
Move to rv-xvi.c for 16-bit emulation ğŸ“ˆ.
Share bugs or feature ideas! ğŸ

Happy emulating! ğŸˆ
