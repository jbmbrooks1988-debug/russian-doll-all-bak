# ğŸ“š RV-IV Emulator Documentation ğŸš€

Welcome to the **RV-IV Emulator**! ğŸ‰ This 4-bit RISC-V-inspired emulator builds on RV-II, scaling up to handle larger values and programs while maintaining simplicity and modularity. Itâ€™s a key step toward a full RV32I emulator, ideal for learning and experimentation! ğŸ˜„ This guide is for **users** running programs and **developers** extending the system. Letâ€™s dive in! ğŸŒŠ

## ğŸŒŸ What is RV-IV? ğŸŒŸ
RV-IV is a 4-bit processor emulator that:
- Runs programs from `in.txt` (or a specified file) ğŸ“œ.
- Writes execution traces to `out.txt` ğŸ“.
- Uses `./+x/nand.+x` for 4-bit NAND operations âš¡.
- Keeps code simple with arrays, no structs ğŸ§±.
- Supports RV-II compatibility and self-modifying code.
- Paves the way for 8-bit, 16-bit, and 32-bit emulators ğŸ“ˆ.

Itâ€™s a mini computer for logic, data movement, and dynamic program changes! ğŸ¦˜

## ğŸ› ï¸ How It Works ğŸ› ï¸
RV-IV features:
- **8 registers** (`r0-r7`), 4-bit each (0-15) ğŸ–ï¸.
- **64-byte memory** (`mem[0-63]`) for programs and data ğŸ’¾.
- **Program counter** (`pc`) to track execution ğŸ—ºï¸.
- **2-byte instructions** fetched from memory ğŸ“–.

### ğŸ’» Instruction Set
Each instruction is 2 bytes:
- **Byte 1** (`mem[pc]`): `opcode = (mem[pc] >> 4) & 0x3`, `op1 = mem[pc] & 0x7`.
- **Byte 2** (`mem[pc+1]`): `op2`, second operand (0-63).
- **PC Update**: `pc += 2`, unless JUMP overrides.

| Opcode | Name  | Action                     | Description                              |
|--------|-------|----------------------------|------------------------------------------|
| 0      | NAND  | `reg[op1] = NAND(reg[op1], reg[op2])` | 4-bit NAND, store in `reg[op1]` ğŸ”§ |
| 1      | LOAD  | `reg[op1] = mem[op2] & 0xF` | Load 4 bits from `mem[op2]` to `reg[op1]` ğŸ“¥ |
| 2      | STORE | `mem[op2] = reg[op1] & 0xF` | Store `reg[op1]` to `mem[op2]` ğŸ“¤         |
| 3      | JUMP  | `pc = (reg[op1] & 0x1F) * 2` | Jump to `reg[op1] * 2` (aligned address) ğŸ¦˜ |

- **NAND**: Calls `./+x/nand.+x 4 a b` â†’ `~(a & b) & 0xF`. Core logic operation! â¤ï¸
- **JUMP**: Uses lower 5 bits of `reg[op1]` (0-31), multiplies by 2 for even addresses (0, 2, ..., 62).
- **Self-Modifying Code**: STORE can overwrite instructions, enabling dynamic behavior.

### ğŸ“‚ File I/O
- **Input**: Reads `in.txt` or a file via `./+x/rv-iv.+x myprog.txt` ğŸ“„.
  - Format: Space-separated bytes (e.g., `1 2 17 0`).
- **Output**: Writes trace to `out.txt` ğŸ“.
  - Format: `EXEC: opcode, op1, op2`, action, `PC, REG, MEM[0]`.
- **NAND Module**: `./+x/nand.+x` writes results to `temp.txt` ğŸ› ï¸.

### ğŸ›‘ Safety Features
- Halts if `pc >= 64` (â€œHalted: PC out of boundsâ€) ğŸš«.
- Stops after 100 steps (â€œHalted: Possible infinite loopâ€) ğŸ”„.
- Checks `op2 < 8` for NAND to avoid invalid registers ğŸš¨.

## ğŸ® How to Use It (Users) ğŸ®
1. **Write a Program** âœï¸:
   - Create `in.txt` with instruction bytes.
   - Example:
     ```
     1 2    // NAND r1, r2 (r1 = 15)
     17 0   // LOAD r1, mem[0] (r1 = 1)
     33 2   // STORE r1, mem[2] (mem[2] = 1, changes LOAD to NAND)
     49 0   // JUMP r1 (jumps based on r1)
     ```
2. **Compile** ğŸ› ï¸:
   ```bash
   gcc rv-iv.c -o /+x/rv-iv.+x
   gcc nand.c -o /+x/nand.+x
   ```
3. **Run** ğŸƒ:
   ```bash
   ./+x/rv-iv.+x in.txt
   ```
   Or default:
   ```bash
   ./+x/rv-iv.+x
   ```
4. **Check Output** ğŸ‘€:
   ```bash
   cat out.txt
   ```
   Example:
   ```
   EXEC: opcode=0, op1=1, op2=2
   NAND r1, r2 -> r1
   PC: 2, REG: [0,15,0,0,0,0,0,0], MEM[0]: 1
   EXEC: opcode=1, op1=1, op2=0
   LOAD r1, mem[0]
   PC: 4, REG: [0,1,0,0,0,0,0,0], MEM[0]: 1
   ...
   Halted: PC out of bounds
   ```

## ğŸ§‘â€ğŸ’» For Developers ğŸ§‘â€ğŸ’»
Ready to hack RV-IV? Hereâ€™s the scoop! ğŸ”

### ğŸ“‚ File Structure
- **rv-iv.c**: Emulator core, handles execution and I/O ğŸ“Ÿ.
- **nand.c**: NAND logic, compiled to `./+x/nand.+x` âš™ï¸.
- **/+x/**: Stores executables (`rv-iv.+x`, `nand.+x`) ğŸ—‚ï¸.

### ğŸ”§ Key Functions
- **main()**: Initializes registers/memory, loads program, runs loop.
- **nand_op()**: Calls `./+x/nand.+x`, reads `temp.txt`.

### ğŸ› ï¸ Extending RV-IV
RV-IV is a stepping stone to `rv-viii` (8-bit), `rv-xvi` (16-bit), and `rv-xxxii` (RV32I). To extend:
- **Scale Up**: Increase registers/memory (e.g., 16 registers for rv-viii).
- **Add Instructions**: Implement ADD, SUB, etc., via NAND.
- **Compatibility**: Ensure RV-II/IV programs run (mask to 2/4 bits).
- **Reuse NAND**: `./+x/nand.+x` supports wider bits (e.g., `./+x/nand.+x 8 a b`).

### ğŸ› Debugging Tips
- **Trace out.txt**: Verify `EXEC` logs for opcodes/operands.
- **Test NAND**: `./+x/nand.+x 4 0 0` should output 15.
- **Validate in.txt**: Check `opcode = (byte >> 4) & 0x3`, `op1 = byte & 0x7`.
- **Self-Modification**: STORE to instruction addresses (e.g., `mem[2]`) changes behavior.

## ğŸš€ Example Walkthrough ğŸš€
For `in.txt`:
```
1 2    // NAND r1, r2
17 0   // LOAD r1, mem[0]
33 2   // STORE r1, mem[2]
49 0   // JUMP r1
```
- **Initial**: `reg=[0,0,0,0,0,0,0,0]`, `mem=[1,2,17,0,33,2,49,0,0,...]`.
- **PC=0**: NAND r1, r2 â†’ `r1=15`.
- **PC=2**: LOAD r1, mem[0] â†’ `r1=1`.
- **PC=4**: STORE r1, mem[2] â†’ `mem[2]=1` (LOAD becomes NAND).
- **PC=6**: JUMP r1 â†’ `PC=2` (r1=1).
- **PC=2**: NAND r1, r0 â†’ `r1=15` (due to `mem[2]=1`).
- **PC=4**: STORE r1, mem[2] â†’ `mem[2]=15`.
- **PC=6**: JUMP r1 â†’ `PC=30` (r1=15).
- **PC=30-62**: NAND r0, r0 â†’ toggles `r0` between 15 and 0.
- **PC=64**: Halts with â€œHalted: PC out of boundsâ€.

This showcases **self-modifying code**, where STORE dynamically alters the program flow! ğŸ§™

## ğŸŒˆ Why RV-IV? ğŸŒˆ
- **Modular**: Reuses `nand.+x` for logic.
- **Simple**: Arrays keep code clear.
- **Scalable**: Steps toward RV32I with RV-II compatibility.
- **Dynamic**: Self-modifying code enables creative programs.

## ğŸ“¢ Next Steps
- Test new `in.txt` programs to explore self-modification ğŸ§ª.
- Move to `rv-viii.c` for 8-bit emulation ğŸ“ˆ.
- Share bugs or feature ideas! ğŸ

Happy emulating! ğŸˆ