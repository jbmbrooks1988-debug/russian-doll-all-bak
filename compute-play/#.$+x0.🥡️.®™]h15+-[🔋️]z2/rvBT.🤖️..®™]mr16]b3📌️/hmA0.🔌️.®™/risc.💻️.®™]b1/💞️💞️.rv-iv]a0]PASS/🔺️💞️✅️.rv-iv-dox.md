# 📚 RV-IV Emulator Documentation 🚀

Welcome to the **RV-IV Emulator**! 🎉 This 4-bit RISC-V-inspired emulator builds on RV-II, scaling up to handle larger values and programs while maintaining simplicity and modularity. It’s a key step toward a full RV32I emulator, ideal for learning and experimentation! 😄 This guide is for **users** running programs and **developers** extending the system. Let’s dive in! 🌊

## 🌟 What is RV-IV? 🌟
RV-IV is a 4-bit processor emulator that:
- Runs programs from `in.txt` (or a specified file) 📜.
- Writes execution traces to `out.txt` 📝.
- Uses `./+x/nand.+x` for 4-bit NAND operations ⚡.
- Keeps code simple with arrays, no structs 🧱.
- Supports RV-II compatibility and self-modifying code.
- Paves the way for 8-bit, 16-bit, and 32-bit emulators 📈.

It’s a mini computer for logic, data movement, and dynamic program changes! 🦘

## 🛠️ How It Works 🛠️
RV-IV features:
- **8 registers** (`r0-r7`), 4-bit each (0-15) 🖐️.
- **64-byte memory** (`mem[0-63]`) for programs and data 💾.
- **Program counter** (`pc`) to track execution 🗺️.
- **2-byte instructions** fetched from memory 📖.

### 💻 Instruction Set
Each instruction is 2 bytes:
- **Byte 1** (`mem[pc]`): `opcode = (mem[pc] >> 4) & 0x3`, `op1 = mem[pc] & 0x7`.
- **Byte 2** (`mem[pc+1]`): `op2`, second operand (0-63).
- **PC Update**: `pc += 2`, unless JUMP overrides.

| Opcode | Name  | Action                     | Description                              |
|--------|-------|----------------------------|------------------------------------------|
| 0      | NAND  | `reg[op1] = NAND(reg[op1], reg[op2])` | 4-bit NAND, store in `reg[op1]` 🔧 |
| 1      | LOAD  | `reg[op1] = mem[op2] & 0xF` | Load 4 bits from `mem[op2]` to `reg[op1]` 📥 |
| 2      | STORE | `mem[op2] = reg[op1] & 0xF` | Store `reg[op1]` to `mem[op2]` 📤         |
| 3      | JUMP  | `pc = (reg[op1] & 0x1F) * 2` | Jump to `reg[op1] * 2` (aligned address) 🦘 |

- **NAND**: Calls `./+x/nand.+x 4 a b` → `~(a & b) & 0xF`. Core logic operation! ❤️
- **JUMP**: Uses lower 5 bits of `reg[op1]` (0-31), multiplies by 2 for even addresses (0, 2, ..., 62).
- **Self-Modifying Code**: STORE can overwrite instructions, enabling dynamic behavior.

### 📂 File I/O
- **Input**: Reads `in.txt` or a file via `./+x/rv-iv.+x myprog.txt` 📄.
  - Format: Space-separated bytes (e.g., `1 2 17 0`).
- **Output**: Writes trace to `out.txt` 📝.
  - Format: `EXEC: opcode, op1, op2`, action, `PC, REG, MEM[0]`.
- **NAND Module**: `./+x/nand.+x` writes results to `temp.txt` 🛠️.

### 🛑 Safety Features
- Halts if `pc >= 64` (“Halted: PC out of bounds”) 🚫.
- Stops after 100 steps (“Halted: Possible infinite loop”) 🔄.
- Checks `op2 < 8` for NAND to avoid invalid registers 🚨.

## 🎮 How to Use It (Users) 🎮
1. **Write a Program** ✍️:
   - Create `in.txt` with instruction bytes.
   - Example:
     ```
     1 2    // NAND r1, r2 (r1 = 15)
     17 0   // LOAD r1, mem[0] (r1 = 1)
     33 2   // STORE r1, mem[2] (mem[2] = 1, changes LOAD to NAND)
     49 0   // JUMP r1 (jumps based on r1)
     ```
2. **Compile** 🛠️:
   ```bash
   gcc rv-iv.c -o /+x/rv-iv.+x
   gcc nand.c -o /+x/nand.+x
   ```
3. **Run** 🏃:
   ```bash
   ./+x/rv-iv.+x in.txt
   ```
   Or default:
   ```bash
   ./+x/rv-iv.+x
   ```
4. **Check Output** 👀:
   ```bash
   cat out.txt
   ```
   Example:
   ```
   EXEC: opcode=0, op1=1, op2=2
   NAND r1, r2 -> r1
   PC: 2, REG: [0,15,0,0,0,0,0,0], MEM[0]: 1
   EXEC: opcode=1, op1=1, op2=0
   LOAD r1, mem[0]
   PC: 4, REG: [0,1,0,0,0,0,0,0], MEM[0]: 1
   ...
   Halted: PC out of bounds
   ```

## 🧑‍💻 For Developers 🧑‍💻
Ready to hack RV-IV? Here’s the scoop! 🔍

### 📂 File Structure
- **rv-iv.c**: Emulator core, handles execution and I/O 📟.
- **nand.c**: NAND logic, compiled to `./+x/nand.+x` ⚙️.
- **/+x/**: Stores executables (`rv-iv.+x`, `nand.+x`) 🗂️.

### 🔧 Key Functions
- **main()**: Initializes registers/memory, loads program, runs loop.
- **nand_op()**: Calls `./+x/nand.+x`, reads `temp.txt`.

### 🛠️ Extending RV-IV
RV-IV is a stepping stone to `rv-viii` (8-bit), `rv-xvi` (16-bit), and `rv-xxxii` (RV32I). To extend:
- **Scale Up**: Increase registers/memory (e.g., 16 registers for rv-viii).
- **Add Instructions**: Implement ADD, SUB, etc., via NAND.
- **Compatibility**: Ensure RV-II/IV programs run (mask to 2/4 bits).
- **Reuse NAND**: `./+x/nand.+x` supports wider bits (e.g., `./+x/nand.+x 8 a b`).

### 🐛 Debugging Tips
- **Trace out.txt**: Verify `EXEC` logs for opcodes/operands.
- **Test NAND**: `./+x/nand.+x 4 0 0` should output 15.
- **Validate in.txt**: Check `opcode = (byte >> 4) & 0x3`, `op1 = byte & 0x7`.
- **Self-Modification**: STORE to instruction addresses (e.g., `mem[2]`) changes behavior.

## 🚀 Example Walkthrough 🚀
For `in.txt`:
```
1 2    // NAND r1, r2
17 0   // LOAD r1, mem[0]
33 2   // STORE r1, mem[2]
49 0   // JUMP r1
```
- **Initial**: `reg=[0,0,0,0,0,0,0,0]`, `mem=[1,2,17,0,33,2,49,0,0,...]`.
- **PC=0**: NAND r1, r2 → `r1=15`.
- **PC=2**: LOAD r1, mem[0] → `r1=1`.
- **PC=4**: STORE r1, mem[2] → `mem[2]=1` (LOAD becomes NAND).
- **PC=6**: JUMP r1 → `PC=2` (r1=1).
- **PC=2**: NAND r1, r0 → `r1=15` (due to `mem[2]=1`).
- **PC=4**: STORE r1, mem[2] → `mem[2]=15`.
- **PC=6**: JUMP r1 → `PC=30` (r1=15).
- **PC=30-62**: NAND r0, r0 → toggles `r0` between 15 and 0.
- **PC=64**: Halts with “Halted: PC out of bounds”.

This showcases **self-modifying code**, where STORE dynamically alters the program flow! 🧙

## 🌈 Why RV-IV? 🌈
- **Modular**: Reuses `nand.+x` for logic.
- **Simple**: Arrays keep code clear.
- **Scalable**: Steps toward RV32I with RV-II compatibility.
- **Dynamic**: Self-modifying code enables creative programs.

## 📢 Next Steps
- Test new `in.txt` programs to explore self-modification 🧪.
- Move to `rv-viii.c` for 8-bit emulation 📈.
- Share bugs or feature ideas! 🐞

Happy emulating! 🎈