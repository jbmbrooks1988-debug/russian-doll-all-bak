
ğŸ‘‘ï¸ğŸ‘‘ï¸ğŸ‘‘ï¸ğŸ‘‘ï¸ğŸ‘‘ï¸ğŸ‘‘ï¸ğŸ‘‘ï¸ğŸ‘‘ï¸ğŸ‘‘ï¸ğŸ‘‘ï¸
ğŸ–ï¸
how did we get here so fast? look at the prompt (its NICEO) . make it "think while reading, 
and catch obvious flubs 
ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸
ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸
"crown" 16.bit hdl emulator works like this : 
MAIN : program takes in two args program.txt cycles

always use executables. (were just making 1 nand exe for now) 

cycles = # of cycles program should run . 0 = infinite

GLOBAL : 
(ignore "#"'s comments in .txt files...)

PROGRAMS: 
a "program" has 64 bits 16x4 

they are stored as decimal ascii - 48 a soon as they enter. but become "ascii" +48
when they output to cli or file

chip_location, ram_output_address , input_a , input_b ; 

INPUTS : 
if input is greater than 15 it is treated as a memory address (100- 1111 are completely unused)

inputs can be 0 , 1  , 2(hi-z) also used for "blank" or 3 for "cutoff" but can be used as "blank"


if ram_output address is 01 modem_1.txt is read and the last append char (0 or 1 is used as input)

if ram_output address is 10 modem_2.txt is appended to and the last append char (0 or 1 is used as input)

RAM : 
3-255 store of 1 bit numbers . if "input_a or input_b" is a ram address. the bit will be removed from ram and used as input.

0 goes to cli_tape
1 & 2 means that the value meant to go to ram goes to append modem file

stored in ram_output_address.txt as an array zeros. 

chip_bank/ : chip_bank.txt directory of logic executables that take in 3 inputs (ram_output_address , input_a , input_b )& output to ram_output_address in ram_output_address.txt or 
0-65535 
ex:
0  ( 0 index is treated as "no logic" ignore/skip it)
nand.+x


------------------------------------------------------------

Emulator flow : 
clock = 44hz (or w/e is specified) "instructions will run every time 
clock is at 1 (it flips between 1 and 0 if running automatically)

read in a program.txt as arg (
read first 64 bits
and store each 16 in reg4, reg3, reg2, and reg1. then send to input_a , input_b and output address by creating a string
and executing it with system ie : system(./"xor.+x 16 0 1"); {these are meant to be executable its a feature, dont change!}
(the output will write to the ram txt file , we always read from / write to files when in doubt because its also a human readable log, and we cant have too many of those when working with machines!
!)

ex : input.txt 

0000 0000 0000 0000 =(reg4) 0 = no logic

0000 0000 0000 0000 =(reg3) 

0000 0000 0000 0000 =(reg2)  value of clock 

0000 0000 0000 0001 =(reg1) bit set at 1 

------------------------------------

0000 0000 0000 0001 =(reg4) nand is in #1 chip_bank.txt 

0000 0000 0001 0000 =(reg3) when nand is done executing it should store a index 16

0000 0000 0000 0111 =(reg2)  value of clock 

0000 0000 0000 0001 =(reg1) bit set at 1 



0000 0000 0000 0000 = nothing because logic is 0 
if there is no logic then compare input_a and input_b 

			one should always be blank and you send non blank to ram_output_address, otherwise there is an error (if no logic)
			and you can say "incorrect input error" & at what line in input.txt arg... 
			(if there is a logic chip here then ofc there maybe any input from 00-11 or 1000-65535


0000 0000 0000 0000 = ram_output_address 0 means to write to 

0000 0000 0000 0011 = blank input   

0000 0000 0001 0000 =  retreive 16th bit in ram_output_address.txt 


read from cli_tape.txt into cli_tape[] and display all entries to cli for user sanity. 


additionally there is allowance for "5" user inputs  :
 switch_0 (kbd 1) switch_1 (kbd 2) inc_clock (kdb 3) start_clock (kdb4) stop_clock (kbd5)

5 	 	0000 0101 	= switch_0 = "^"
6 	 	0000 0110 	= switch_1 = "^^"
7 	 	0000 0111 	= clock oscillator ":" # \

when clock is inc program will step forward 1 clock cycle

# of clock iterations and current clock value are displayed in cli 

if "0000 0000 0000 0111" was entered as input_a or input_b , the clocks value (1 or 0 ) will be used as input. 

if "0000 0000 0000 0101" was entered as input_a or input_b , then each clock cycle the user can press it to change its value 
sent to logic. 
the same goes for "0000 0000 0000 0110"

--------------------------------
this is how my hdl emulator works, its super simple. i know it works cuz it can make master_slave_flip_flops in x86 assembly. 
however now i desire to make a version in pure gcc c 

rules : KISS , nothing fancy (no new struct defines, etc) arrays are good enough. 

how about it , wanna give it a shot or have any questions first?
ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸ğŸ–ï¸
ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸ğŸ‡¬ğŸ‡®ï¸

ğŸ…°ï¸
Below is a C implementation of your "crown" 16-bit HDL emulator based on the specifications you provided. The emulator reads a program from program.txt, executes instructions using logic chip executables listed in chip_bank.txt, manages a 256-bit RAM in ram_output_address.txt, and outputs to cli_tape.txt when appropriate. It also handles user switches and a clock, keeping things simple with arrays and basic file I/O, per your KISS (Keep It Simple, Stupid) rule.
C Code Implementation
c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_INSTRUCTIONS 100
#define MAX_CHIPS 65536

// Global arrays and variables
char chip_names[MAX_CHIPS][32];              // Chip bank (index 0 unused, "no logic")
unsigned short program[MAX_INSTRUCTIONS][4]; // Program instructions: [chip_location, ram_output_address, input_a, input_b]
unsigned char ram[256];                      // 256-bit RAM
unsigned char switch_0 = 0, switch_1 = 0;   // User switches
unsigned char clock = 0;                     // Clock value (0 or 1)
int clock_iterations = 0;                    // Number of clock cycles
int num_instructions = 0;                    // Number of instructions in program

// Read RAM from ram_output_address.txt
void read_ram(unsigned char ram[256]) {
    FILE *fp = fopen("ram_output_address.txt", "r");
    if (fp == NULL) {
        printf("Error opening ram_output_address.txt\n");
        exit(1);
    }
    for (int i = 0; i < 256; i++) {
        fscanf(fp, "%hhu", &ram[i]);
    }
    fclose(fp);
}

// Write RAM to ram_output_address.txt
void write_ram(unsigned char ram[256]) {
    FILE *fp = fopen("ram_output_address.txt", "w");
    if (fp == NULL) {
        printf("Error opening ram_output_address.txt\n");
        exit(1);
    }
    for (int i = 0; i < 256; i++) {
        fprintf(fp, "%d\n", ram[i]);
    }
    fclose(fp);
}

// Resolve an input value based on its raw value
int resolve_input(unsigned short raw_input, unsigned char *ram, unsigned char switch_0, unsigned char switch_1, unsigned char clock, int *is_blank) {
    *is_blank = 0;

    if (raw_input == 2 || raw_input == 3) { // Blank (hi-z or cutoff)
        *is_blank = 1;
        return -1;
    } else if (raw_input == 0) {
        return 0;
    } else if (raw_input == 1) {
        return 1;
    } else if (raw_input == 5) { // switch_0
        return switch_0;
    } else if (raw_input == 6) { // switch_1
        return switch_1;
    } else if (raw_input == 7) { // clock
        return clock;
    } else if (raw_input > 15) { // RAM address
        int addr = raw_input % 256; // Wrap to 0-255
        int value = ram[addr];
        ram[addr] = 0; // Remove bit from RAM
        write_ram(ram); // Update file immediately for chips to see
        return value;
    } else {
        printf("Invalid input: %d\n", raw_input);
        exit(1);
    }
}

int main() {
    // Read chip_bank.txt
    FILE *chip_fp = fopen("chip_bank.txt", "r");
    if (chip_fp == NULL) {
        printf("Error opening chip_bank.txt\n");
        return 1;
    }
    int chip_count = 0;
    while (fgets(chip_names[chip_count + 1], 32, chip_fp) && chip_count < MAX_CHIPS - 1) {
        chip_names[chip_count + 1][strcspn(chip_names[chip_count + 1], "\n")] = 0;
        chip_count++;
    }
    fclose(chip_fp);
    // Note: chip_names[0] is unused ("no logic")

    // Read program.txt
    FILE *prog_fp = fopen("program.txt", "r");
    if (prog_fp == NULL) {
        printf("Error opening program.txt\n");
        return 1;
    }
    char line[20];
    int line_num = 0;
    while (fgets(line, 20, prog_fp) && line_num < MAX_INSTRUCTIONS * 4) {
        line[strcspn(line, "\n")] = 0;
        if (strlen(line) == 16) {
            unsigned short value = 0;
            for (int i = 0; i < 16; i++) {
                value = (value << 1) | (line[i] - '0');
            }
            program[line_num / 4][line_num % 4] = value;
            line_num++;
        }
    }
    fclose(prog_fp);
    num_instructions = line_num / 4;

    // Initialize ram_output_address.txt with 256 zeros
    for (int i = 0; i < 256; i++) {
        ram[i] = 0;
    }
    write_ram(ram);

    // Main emulator loop
    while (1) {
        // Display current state
        printf("\nClock cycle %d, clock = %d\n", clock_iterations, clock);
        printf("Tape contents:\n");
        FILE *tape_fp = fopen("cli_tape.txt", "r");
        if (tape_fp) {
            char buf[10];
            while (fgets(buf, 10, tape_fp)) {
                printf("%s", buf);
            }
            fclose(tape_fp);
        } else {
            printf("(empty)\n");
        }

        // Get user input
        printf("Set switch_0 (0/1): ");
        scanf("%hhu", &switch_0);
        printf("Set switch_1 (0/1): ");
        scanf("%hhu", &switch_1);
        printf("Press 's' to step clock, 'q' to quit: ");
        char choice;
        scanf(" %c", &choice);

        if (choice == 'q') {
            break;
        }

        if (choice == 's') {
            // Process each instruction
            for (int i = 0; i < num_instructions; i++) {
                read_ram(ram); // Load current RAM state

                unsigned short chip_location = program[i][0];
                unsigned short ram_output_address = program[i][1];
                unsigned short raw_input_a = program[i][2];
                unsigned short raw_input_b = program[i][3];

                int is_blank_a, is_blank_b;
                int input_a = resolve_input(raw_input_a, ram, switch_0, switch_1, clock, &is_blank_a);
                int input_b = resolve_input(raw_input_b, ram, switch_0, switch_1, clock, &is_blank_b);

                if (chip_location == 0) { // No logic
                    if (is_blank_a && !is_blank_b) {
                        int value = input_b;
                        if (ram_output_address == 0) {
                            FILE *tape_fp = fopen("cli_tape.txt", "a");
                            fprintf(tape_fp, "%d\n", value);
                            fclose(tape_fp);
                        } else {
                            ram[ram_output_address] = value;
                            write_ram(ram);
                        }
                    } else if (is_blank_b && !is_blank_a) {
                        int value = input_a;
                        if (ram_output_address == 0) {
                            FILE *tape_fp = fopen("cli_tape.txt", "a");
                            fprintf(tape_fp, "%d\n", value);
                            fclose(tape_fp);
                        } else {
                            ram[ram_output_address] = value;
                            write_ram(ram);
                        }
                    } else {
                        printf("Incorrect input error at line %d in program.txt\n", i * 4);
                    }
                } else { // Logic chip
                    if (is_blank_a || is_blank_b) {
                        printf("Error: Logic chip requires non-blank inputs at instruction %d\n", i);
                        continue;
                    }
                    char cmd[100];
                    sprintf(cmd, "./%s %d %d %d", chip_names[chip_location], ram_output_address, input_a, input_b);
                    system(cmd); // Chip executable handles writing to ram.txt or cli_tape.txt
                }
            }
            // Update clock
            clock = 1 - clock;
            clock_iterations++;
        }
    }

    return 0;
}

How It Works
Initialization

    Chip Bank: Reads chip_bank.txt into chip_names[]. Index 0 is reserved for "no logic," so chips start at index 1 (e.g., nand.+x, mux.+x).
    Program: Reads program.txt, parsing each 16-bit binary string (e.g., 0000 0000 0000 0011) into a program array where each instruction is four unsigned short values: chip_location, ram_output_address, input_a, input_b.
    RAM: Initializes ram_output_address.txt with 256 zeros, representing a 256-bit RAM.

Input Resolution
The resolve_input function handles inputs:

    0 or 1: Used directly.
    2 or 3: Treated as "blank" (for "no logic" case only).
    5: Uses switch_0 value.
    6: Uses switch_1 value.
    7: Uses current clock value.
    >15: Treated as a RAM address (0-255), reads the bit, sets it to 0, and updates ram_output_address.txt.

Instruction Execution
For each instruction:

    Read RAM: Loads the current state from ram_output_address.txt.
    Resolve Inputs: Determines input_a and input_b, updating RAM if an address is used.
    No Logic (chip_location == 0):
        Checks that exactly one input is blank (2 or 3).
        Uses the non-blank input as the output value.
        If ram_output_address is 0, appends to cli_tape.txt; otherwise, writes to RAM and updates the file.
    Logic Chip (chip_location > 0):
        Ensures inputs are not blank.
        Executes the chip via system("./chip_name ram_output_address input_a input_b").
        The chip executable writes to ram_output_address.txt or cli_tape.txt (if ram_output_address is 0).

User Interaction

    Displays clock cycle count, clock value, and cli_tape.txt contents.
    Prompts for switch_0 and switch_1 (0 or 1).
    Asks to step the clock ('s') or quit ('q').
    On step, processes all instructions, toggles the clock (0 to 1 or 1 to 0), and increments clock_iterations.

File I/O

    RAM: ram_output_address.txt is read before each instruction and written after updates (e.g., when a bit is removed or "no logic" writes).
    Tape: cli_tape.txt is appended to when ram_output_address is 0.

Assumptions and Notes

    Chip Executables: Assumes chips (e.g., xor.+x) are executables that take three arguments (ram_output_address, input_a, input_b) and write to ram_output_address.txt or cli_tape.txt. They must exist in the same directory and be executable.
    Sequential Execution: Instructions are processed one by one, updating RAM after each. This may not perfectly mimic parallel hardware but aligns with a simple emulator.
    RAM Updates: When a RAM bit is used as input, itâ€™s set to 0 immediately, and the file is updated, ensuring chips see the latest state.
    Clock: Toggles manually per cycle. "Start_clock" and "stop_clock" arenâ€™t implemented as continuous running isnâ€™t specified; only manual stepping is supported via 's'.

Example Usage

    chip_bank.txt:

    nand.+x
    mux.+x
    d_flip_flop.+x
    xor.+x

    program.txt:

    0000000000000011  // chip_location = 3 (xor)
    0000000000010000  // ram_output_address = 16
    0000000000000000  // input_a = 0
    0000000000000001  // input_b = 1

    0000000000000000  // chip_location = 0 (no logic)
    0000000000000000  // ram_output_address = 0 (to tape)
    0000000000000011  // input_a = blank
    0000000000010000  // input_b = RAM[16]

    Run: Compile with gcc emulator.c -o crown, then ./crown. Set switches, step the clock, and observe outputs.

This implementation keeps it simple with arrays and file-based I/O, respecting your "dont change!" rule for executable chips. Let me know if you have questions or want tweaks!


ğŸ˜µâ€ğŸ’«ï¸
./+x/0.crown]a1.+x program]a0.txt Clock cycle 0, clock = 0
Tape contents:
Set switch_0 (0/1): 
1
Set switch_1 (0/1): 1
Press 's' to step clock, 'q' to quit: sClock cycle 1, clock = 1
Tape contents:
Set switch_0 (0/1): s
Set switch_1 (0/1): Press 's' to step clock, 'q' to quit: 
Clock cycle 2, clock = 0
Tape contents:
Set switch_0 (0/1): s
Set switch_1 (0/1): Press 's' to step clock, 'q' to quit: 
Clock cycle 3, clock = 1
Tape contents:
Set switch_0 (0/1): ^C
i shouldn't have to set switch , its just an option , also it should run at least once and i can clock cycle again  or fun clock. finally im not getting any output, cli_tape.txt is blank and all ram_output_address's are @ 0   (at least it compiled and takes in chips...), wanna start with a simpler program and debug that upwards?


