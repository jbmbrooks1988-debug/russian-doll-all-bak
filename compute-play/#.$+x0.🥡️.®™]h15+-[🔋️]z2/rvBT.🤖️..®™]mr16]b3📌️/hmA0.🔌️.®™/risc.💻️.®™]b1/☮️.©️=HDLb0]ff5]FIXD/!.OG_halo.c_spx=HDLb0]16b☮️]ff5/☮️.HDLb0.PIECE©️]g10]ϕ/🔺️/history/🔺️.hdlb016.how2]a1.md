# 🎉 HDLb0 Emulator Instructions 🚀💾

Welcome to the **HDLb0 Emulator** (`/+x/0.hdlb0.☮️16]x0]PERF.+x`)! 🌟 This is your guide to rocking this binary-based hardware emulator, whether you’re a **user** building cool circuits or a **developer** hacking its guts! 🛠️😎 It’s a standalone beast, separate from any RV-II stuff, and uses pure 16-bit binary to simulate digital logic. Let’s dive in with a million thanks for using it! 💖🙌

## 🌈 What is HDLb0? 🖥️
HDLb0 is a super-fun emulator that mimics hardware circuits using 16-bit binary instructions! 🎮 It runs on a C program, reads from a program file (e.g., `mod_in.txt`), and uses chips like NAND, modem_in, and modem_out to process data. Here’s the vibe:
- **Inputs**: Switches (`switch_0`, `switch_1`), clock, RAM, or literals (0, 1). 🔌
- **Outputs**: Write to `cli_tape.txt` or 256-byte RAM. 📜💾
- **Chips**: NAND for logic, modem_in/out for file I/O. 🔧📡
- **Clock**: Toggles between 0 and 1 per cycle. ⏰
- **Goal**: Build circuits like XOR or adders using binary instructions! 🧩

Ready to play? Let’s go! 🚴‍♀️

---

## 🎮 For Users: How to Use HDLb0 🕹️

### 1. 🛠️ Setup the Emulator
1. **Compile the Emulator**:
   ```bash
   gcc -o +x/0.hdlb0.☮️16]x0]PERF.+x 0.hdlb0.☮️16]x0]PERF.c
   gcc -o +x/nand.+x nand.c
   gcc -o +x/modem_in.+x modem_in.c
   gcc -o +x/modem_out.+x modem_out.c
   ```
   📦 Make sure all `.c` files are in your directory!

2. **Create chip_bank.txt**:
   ```
   +x/nand.+x
   +x/modem_in.+x
   +x/modem_out.+x
   ```
   📋 This lists chips at positions 1, 2, and 3. Place it in your current directory.

3. **Prepare a Program File**:
   Create a file (e.g., `mod_in.txt`) with 16-bit binary instructions (more below). 📝

### 2. 📜 Program File Format
Each instruction is **four 16-bit binary strings** in a text file (e.g., `mod_in.txt`):
- **Chip Location** (1st): Which chip to use (0 = pass-through, 1 = NAND, 2 = modem_in, 3 = modem_out). 🧑‍🔧
- **Output Address** (2nd): Where to write the result (0 = `cli_tape.txt`, 1–255 = RAM address). 📤
- **Input A** (3rd): First input (0, 1, 2/3 = blank, 5 = switch_0, 6 = switch_1, 7 = clock, >15 = RAM address). 🔍
- **Input B** (4th): Second input (same as Input A). 🔎

**Example** (read from `modem/26.txt`, write to `cli_tape.txt`):
```
0000000000000010  # Chip: modem_in (2)
0000000000011010  # Read from modem/26.txt
0000000000000000  # Write to cli_tape.txt
0000000000000000  # Ignored
```

### 3. 🏃 Run the Emulator
```bash
./+x/0.hdlb0.☮️16]x0]PERF.+x mod_in.txt
```
- **Initial Run**: Executes one clock cycle. ⏳
- **Output**: Shows `cli_tape.txt` contents, switch states (`switch_0`, `switch_1`), and clock (0 or 1). 📺
- **Options**:
  - `1`: Flip `switch_0` (0 ↔ 1). 🔘
  - `2`: Flip `switch_1` (0 ↔ 1). 🔘
  - `s`: Step one cycle. 🚶
  - `r`: Run continuously (clear screen each cycle). 🏃‍♂️
  - `q`: Quit. 🛑

**Example Output**:
```
Initial run:
Clock cycle 1, clock = 1
Tape contents:
1
Switches: switch_0 = 0, switch_1 = 0
Options: '1' flip switch_0, '2' flip switch_1, 's' step, 'r' run, 'q' quit:
```

### 4. 🎨 Using Chips
- **NAND** (chip 1):
  - Computes `~(input_a & input_b)` and writes to RAM or tape.
  - Example (NAND switch_0, switch_1 to RAM[16]):
    ```
    0000000000000001  # Chip: NAND (1)
    0000000000010000  # Write to RAM[16]
    0000000000000101  # Input A: switch_0 (5)
    0000000000000110  # Input B: switch_1 (6)
    ```
- **modem_in** (chip 2):
  - Reads from `modem/N.txt` (N from 2nd field) and writes to RAM or tape (3rd field).
  - Example (read `modem/26.txt` to `cli_tape.txt`):
    ```
    0000000000000010  # Chip: modem_in (2)
    0000000000011010  # Read from modem/26.txt
    0000000000000000  # Write to cli_tape.txt
    0000000000000000  # Ignored
    ```
  - Creates `modem/` and `modem/N.txt` (with 0) if needed. 🗂️
- **modem_out** (chip 3):
  - Writes input value (3rd field) to `modem/N.txt` (N from 2nd field) or `cli_tape.txt`.
  - Example (write 1 to `modem/10.txt`):
    ```
    0000000000000011  # Chip: modem_out (3)
    0000000000001010  # Write to modem/10.txt
    0000000000000001  # Input_value: 1
    0000000000000000  # Ignored
    ```
  - Creates `modem/` if needed. 🗂️
- **Pass-Through** (chip 0):
  - Passes one input to output if the other is blank (2 or 3).
  - Example (pass RAM[10] to RAM[15]):
    ```
    0000000000000000  # Chip: pass-through (0)
    0000000000001111  # Write to RAM[15]
    0000000000001010  # Input A: RAM[10]
    0000000000000011  # Input B: blank (3)
    ```

### 5. 💡 Tips for Users
- **Create Modem Files**: For `modem_in`, add files like `modem/26.txt` with a number (e.g., `1`). 📄
- **Check Outputs**: Look at `cli_tape.txt` for tape outputs or `ram_output_address.txt` for RAM (256 lines, 0–255). 📊
- **Test Switches**: Use `1` or `2` to flip switches and see results in NAND or pass-through. 🔄
- **Build Circuits**: Combine instructions to make XOR, adders, etc. (see Developer section). 🧩

---

## 🧑‍💻 For Developers: Hacking HDLb0 🛠️

### 1. 📂 File Structure
- **0.hdlb0.☮️16]x0]PERF.c**: The emulator core, reads `program.txt`, executes chips. 🖥️
- **nand.c**: Computes NAND logic (`./+x/nand.+x`). ⚙️
- **modem_in.c**: Reads from `modem/N.txt`, writes to RAM or tape. 📥
- **modem_out.c**: Writes to `modem/N.txt` or tape. 📤
- **chip_bank.txt**: Lists chips at positions 1–3. 📋
- **cli_tape.txt**: Output tape, appended per cycle. 📜
- **ram_output_address.txt**: 256-byte RAM state. 💾
- **modem/**: Directory for modem files (e.g., `modem/26.txt`). 🗂️

### 2. 🔧 How It Works
- **Instruction Processing**:
  - Reads `program.txt` into a 4x16-bit array (chip, output address, input A, input B). 📖
  - Each cycle:
    1. Reads RAM from `ram_output_address.txt`. 💾
    2. Resolves inputs (0, 1, switch_0, switch_1, clock, RAM, or blank). 🔍
    3. Executes chip or pass-through:
       - Chip 0: Passes non-blank input to output. ➡️
       - Chip 1–3: Runs `./+x/<chip>.+x <output> <input_a> <input_b>`. 🏃
    4. Writes to `cli_tape.txt` or RAM. 📤
    5. Toggles clock (0 ↔ 1). ⏰
- **Input Resolution**:
  - 0, 1: Literals. ✅
  - 2, 3: Blank (for pass-through). ❓
  - 5: `switch_0`. 🔘
  - 6: `switch_1`. 🔘
  - 7: Clock (0 or 1). ⏱️
  - >15: Read RAM[address % 256] (no clearing). 💾
  - 8–15: Invalid, returns -1 (avoid these). 🚫
- **Outputs**:
  - Address 0: Append to `cli_tape.txt`. 📜
  - Address 1–255: Write to RAM[address]. 💾

### 3.mt
### 4. 🚀 Extending HDLb0
🔢
- **GUI**: Build an opengl/ HTML/JS/ interface to visualize circuits. 🌐
- **Preprocessor**: Convert human-readable HDL (e.g., `NAND 5 6 -> 16`) to binary. 📜

### 5. 🧩 Example: Building XOR
XOR: `A XOR B = (A NAND (A NAND B)) NAND (B NAND (A NAND B))`.
```
0000000000000001  # NAND: T1 = A NAND B -> RAM[16]
0000000000010000  # Output to RAM[16]
0000000000000101  # Input A: switch_0 (5)
0000000000000110  # Input B: switch_1 (6)

0000000000000001  # NAND: T2 = A NAND T1 -> RAM[17]
0000000000010001  # Output to RAM[17]
0000000000000101  # Input A: switch_0 (5)
0000000000010000  # Input B: RAM[16]

0000000000000001  # NAND: T3 = B NAND T1 -> RAM[18]
0000000000010010  # Output to RAM[18]
0000000000000110  # Input B: switch_1 (6)
0000000000010000  # Input B: RAM[16]

0000000000000001  # NAND: T4 = T2 NAND T3 -> cli_tape.txt
0000000000000000  # Output to cli_tape.txt
0000000000010001  # Input A: RAM[17]
0000000000010010  # Input B: RAM[18]
```
- **Test**: Set switches (`1`, `2`), run (`s` or `r`), check `cli_tape.txt` for XOR results (e.g., 0,1→1). 🎯

### 6. 🧪 Testing Tips
- **Verify Chips**:
  - NAND: `./+x/nand.+x 0 0 1` → `cli_tape.txt` should show `1`.
  - modem_in: Create `modem/26.txt` with `1`, use above example, check `cli_tape.txt`.
  - modem_out: Write to `modem/10.txt`, verify content.
- **Debug RAM**: Check `ram_output_address.txt` for RAM state. 🔍
- **Cycle Steps**: Use `s` to step through cycles, watch clock and tape. ⏰

---

## 🎯 Getting Started
1. **Compile**: See Setup above. 🛠️
2. **Write Program**: Create `mod_in.txt` with binary instructions. 📝
3. **Run**: `./+x/0.hdlb0.☮️16]x0]PERF.+x mod_in.txt`. 🏃
4. **Play**: Flip switches (`1`, `2`), step (`s`), or run (`r`). 🎮
5. **Hack**: Add chips or tools for epic circuits! 🧑‍💻

## 🌟 Why HDLb0?
- **Simple**: Pure binary, no complex structs. 🧱
- **Flexible**: Build any logic with NAND and I/O with modem chips. 🔧📡
- **Fun**: Experiment with switches and tape like a retro computer! 🕹️
- **Portable**: Easy to rewrite in bash, assembly, or VHDL. 🌍

Happy circuit building! 💪😄 Thanks a million for using HDLb0! 💖🚀
