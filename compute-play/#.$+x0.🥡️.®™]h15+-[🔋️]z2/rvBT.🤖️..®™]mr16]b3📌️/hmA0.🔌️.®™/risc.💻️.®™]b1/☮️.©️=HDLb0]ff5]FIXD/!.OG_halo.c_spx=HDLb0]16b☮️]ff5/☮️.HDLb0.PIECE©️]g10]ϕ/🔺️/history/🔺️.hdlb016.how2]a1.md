# ğŸ‰ HDLb0 Emulator Instructions ğŸš€ğŸ’¾

Welcome to the **HDLb0 Emulator** (`/+x/0.hdlb0.â˜®ï¸16]x0]PERF.+x`)! ğŸŒŸ This is your guide to rocking this binary-based hardware emulator, whether youâ€™re a **user** building cool circuits or a **developer** hacking its guts! ğŸ› ï¸ğŸ˜ Itâ€™s a standalone beast, separate from any RV-II stuff, and uses pure 16-bit binary to simulate digital logic. Letâ€™s dive in with a million thanks for using it! ğŸ’–ğŸ™Œ

## ğŸŒˆ What is HDLb0? ğŸ–¥ï¸
HDLb0 is a super-fun emulator that mimics hardware circuits using 16-bit binary instructions! ğŸ® It runs on a C program, reads from a program file (e.g., `mod_in.txt`), and uses chips like NAND, modem_in, and modem_out to process data. Hereâ€™s the vibe:
- **Inputs**: Switches (`switch_0`, `switch_1`), clock, RAM, or literals (0, 1). ğŸ”Œ
- **Outputs**: Write to `cli_tape.txt` or 256-byte RAM. ğŸ“œğŸ’¾
- **Chips**: NAND for logic, modem_in/out for file I/O. ğŸ”§ğŸ“¡
- **Clock**: Toggles between 0 and 1 per cycle. â°
- **Goal**: Build circuits like XOR or adders using binary instructions! ğŸ§©

Ready to play? Letâ€™s go! ğŸš´â€â™€ï¸

---

## ğŸ® For Users: How to Use HDLb0 ğŸ•¹ï¸

### 1. ğŸ› ï¸ Setup the Emulator
1. **Compile the Emulator**:
   ```bash
   gcc -o +x/0.hdlb0.â˜®ï¸16]x0]PERF.+x 0.hdlb0.â˜®ï¸16]x0]PERF.c
   gcc -o +x/nand.+x nand.c
   gcc -o +x/modem_in.+x modem_in.c
   gcc -o +x/modem_out.+x modem_out.c
   ```
   ğŸ“¦ Make sure all `.c` files are in your directory!

2. **Create chip_bank.txt**:
   ```
   +x/nand.+x
   +x/modem_in.+x
   +x/modem_out.+x
   ```
   ğŸ“‹ This lists chips at positions 1, 2, and 3. Place it in your current directory.

3. **Prepare a Program File**:
   Create a file (e.g., `mod_in.txt`) with 16-bit binary instructions (more below). ğŸ“

### 2. ğŸ“œ Program File Format
Each instruction is **four 16-bit binary strings** in a text file (e.g., `mod_in.txt`):
- **Chip Location** (1st): Which chip to use (0 = pass-through, 1 = NAND, 2 = modem_in, 3 = modem_out). ğŸ§‘â€ğŸ”§
- **Output Address** (2nd): Where to write the result (0 = `cli_tape.txt`, 1â€“255 = RAM address). ğŸ“¤
- **Input A** (3rd): First input (0, 1, 2/3 = blank, 5 = switch_0, 6 = switch_1, 7 = clock, >15 = RAM address). ğŸ”
- **Input B** (4th): Second input (same as Input A). ğŸ”

**Example** (read from `modem/26.txt`, write to `cli_tape.txt`):
```
0000000000000010  # Chip: modem_in (2)
0000000000011010  # Read from modem/26.txt
0000000000000000  # Write to cli_tape.txt
0000000000000000  # Ignored
```

### 3. ğŸƒ Run the Emulator
```bash
./+x/0.hdlb0.â˜®ï¸16]x0]PERF.+x mod_in.txt
```
- **Initial Run**: Executes one clock cycle. â³
- **Output**: Shows `cli_tape.txt` contents, switch states (`switch_0`, `switch_1`), and clock (0 or 1). ğŸ“º
- **Options**:
  - `1`: Flip `switch_0` (0 â†” 1). ğŸ”˜
  - `2`: Flip `switch_1` (0 â†” 1). ğŸ”˜
  - `s`: Step one cycle. ğŸš¶
  - `r`: Run continuously (clear screen each cycle). ğŸƒâ€â™‚ï¸
  - `q`: Quit. ğŸ›‘

**Example Output**:
```
Initial run:
Clock cycle 1, clock = 1
Tape contents:
1
Switches: switch_0 = 0, switch_1 = 0
Options: '1' flip switch_0, '2' flip switch_1, 's' step, 'r' run, 'q' quit:
```

### 4. ğŸ¨ Using Chips
- **NAND** (chip 1):
  - Computes `~(input_a & input_b)` and writes to RAM or tape.
  - Example (NAND switch_0, switch_1 to RAM[16]):
    ```
    0000000000000001  # Chip: NAND (1)
    0000000000010000  # Write to RAM[16]
    0000000000000101  # Input A: switch_0 (5)
    0000000000000110  # Input B: switch_1 (6)
    ```
- **modem_in** (chip 2):
  - Reads from `modem/N.txt` (N from 2nd field) and writes to RAM or tape (3rd field).
  - Example (read `modem/26.txt` to `cli_tape.txt`):
    ```
    0000000000000010  # Chip: modem_in (2)
    0000000000011010  # Read from modem/26.txt
    0000000000000000  # Write to cli_tape.txt
    0000000000000000  # Ignored
    ```
  - Creates `modem/` and `modem/N.txt` (with 0) if needed. ğŸ—‚ï¸
- **modem_out** (chip 3):
  - Writes input value (3rd field) to `modem/N.txt` (N from 2nd field) or `cli_tape.txt`.
  - Example (write 1 to `modem/10.txt`):
    ```
    0000000000000011  # Chip: modem_out (3)
    0000000000001010  # Write to modem/10.txt
    0000000000000001  # Input_value: 1
    0000000000000000  # Ignored
    ```
  - Creates `modem/` if needed. ğŸ—‚ï¸
- **Pass-Through** (chip 0):
  - Passes one input to output if the other is blank (2 or 3).
  - Example (pass RAM[10] to RAM[15]):
    ```
    0000000000000000  # Chip: pass-through (0)
    0000000000001111  # Write to RAM[15]
    0000000000001010  # Input A: RAM[10]
    0000000000000011  # Input B: blank (3)
    ```

### 5. ğŸ’¡ Tips for Users
- **Create Modem Files**: For `modem_in`, add files like `modem/26.txt` with a number (e.g., `1`). ğŸ“„
- **Check Outputs**: Look at `cli_tape.txt` for tape outputs or `ram_output_address.txt` for RAM (256 lines, 0â€“255). ğŸ“Š
- **Test Switches**: Use `1` or `2` to flip switches and see results in NAND or pass-through. ğŸ”„
- **Build Circuits**: Combine instructions to make XOR, adders, etc. (see Developer section). ğŸ§©

---

## ğŸ§‘â€ğŸ’» For Developers: Hacking HDLb0 ğŸ› ï¸

### 1. ğŸ“‚ File Structure
- **0.hdlb0.â˜®ï¸16]x0]PERF.c**: The emulator core, reads `program.txt`, executes chips. ğŸ–¥ï¸
- **nand.c**: Computes NAND logic (`./+x/nand.+x`). âš™ï¸
- **modem_in.c**: Reads from `modem/N.txt`, writes to RAM or tape. ğŸ“¥
- **modem_out.c**: Writes to `modem/N.txt` or tape. ğŸ“¤
- **chip_bank.txt**: Lists chips at positions 1â€“3. ğŸ“‹
- **cli_tape.txt**: Output tape, appended per cycle. ğŸ“œ
- **ram_output_address.txt**: 256-byte RAM state. ğŸ’¾
- **modem/**: Directory for modem files (e.g., `modem/26.txt`). ğŸ—‚ï¸

### 2. ğŸ”§ How It Works
- **Instruction Processing**:
  - Reads `program.txt` into a 4x16-bit array (chip, output address, input A, input B). ğŸ“–
  - Each cycle:
    1. Reads RAM from `ram_output_address.txt`. ğŸ’¾
    2. Resolves inputs (0, 1, switch_0, switch_1, clock, RAM, or blank). ğŸ”
    3. Executes chip or pass-through:
       - Chip 0: Passes non-blank input to output. â¡ï¸
       - Chip 1â€“3: Runs `./+x/<chip>.+x <output> <input_a> <input_b>`. ğŸƒ
    4. Writes to `cli_tape.txt` or RAM. ğŸ“¤
    5. Toggles clock (0 â†” 1). â°
- **Input Resolution**:
  - 0, 1: Literals. âœ…
  - 2, 3: Blank (for pass-through). â“
  - 5: `switch_0`. ğŸ”˜
  - 6: `switch_1`. ğŸ”˜
  - 7: Clock (0 or 1). â±ï¸
  - >15: Read RAM[address % 256] (no clearing). ğŸ’¾
  - 8â€“15: Invalid, returns -1 (avoid these). ğŸš«
- **Outputs**:
  - Address 0: Append to `cli_tape.txt`. ğŸ“œ
  - Address 1â€“255: Write to RAM[address]. ğŸ’¾

### 3.mt
### 4. ğŸš€ Extending HDLb0
ğŸ”¢
- **GUI**: Build an opengl/ HTML/JS/ interface to visualize circuits. ğŸŒ
- **Preprocessor**: Convert human-readable HDL (e.g., `NAND 5 6 -> 16`) to binary. ğŸ“œ

### 5. ğŸ§© Example: Building XOR
XOR: `A XOR B = (A NAND (A NAND B)) NAND (B NAND (A NAND B))`.
```
0000000000000001  # NAND: T1 = A NAND B -> RAM[16]
0000000000010000  # Output to RAM[16]
0000000000000101  # Input A: switch_0 (5)
0000000000000110  # Input B: switch_1 (6)

0000000000000001  # NAND: T2 = A NAND T1 -> RAM[17]
0000000000010001  # Output to RAM[17]
0000000000000101  # Input A: switch_0 (5)
0000000000010000  # Input B: RAM[16]

0000000000000001  # NAND: T3 = B NAND T1 -> RAM[18]
0000000000010010  # Output to RAM[18]
0000000000000110  # Input B: switch_1 (6)
0000000000010000  # Input B: RAM[16]

0000000000000001  # NAND: T4 = T2 NAND T3 -> cli_tape.txt
0000000000000000  # Output to cli_tape.txt
0000000000010001  # Input A: RAM[17]
0000000000010010  # Input B: RAM[18]
```
- **Test**: Set switches (`1`, `2`), run (`s` or `r`), check `cli_tape.txt` for XOR results (e.g., 0,1â†’1). ğŸ¯

### 6. ğŸ§ª Testing Tips
- **Verify Chips**:
  - NAND: `./+x/nand.+x 0 0 1` â†’ `cli_tape.txt` should show `1`.
  - modem_in: Create `modem/26.txt` with `1`, use above example, check `cli_tape.txt`.
  - modem_out: Write to `modem/10.txt`, verify content.
- **Debug RAM**: Check `ram_output_address.txt` for RAM state. ğŸ”
- **Cycle Steps**: Use `s` to step through cycles, watch clock and tape. â°

---

## ğŸ¯ Getting Started
1. **Compile**: See Setup above. ğŸ› ï¸
2. **Write Program**: Create `mod_in.txt` with binary instructions. ğŸ“
3. **Run**: `./+x/0.hdlb0.â˜®ï¸16]x0]PERF.+x mod_in.txt`. ğŸƒ
4. **Play**: Flip switches (`1`, `2`), step (`s`), or run (`r`). ğŸ®
5. **Hack**: Add chips or tools for epic circuits! ğŸ§‘â€ğŸ’»

## ğŸŒŸ Why HDLb0?
- **Simple**: Pure binary, no complex structs. ğŸ§±
- **Flexible**: Build any logic with NAND and I/O with modem chips. ğŸ”§ğŸ“¡
- **Fun**: Experiment with switches and tape like a retro computer! ğŸ•¹ï¸
- **Portable**: Easy to rewrite in bash, assembly, or VHDL. ğŸŒ

Happy circuit building! ğŸ’ªğŸ˜„ Thanks a million for using HDLb0! ğŸ’–ğŸš€
