üñãÔ∏èüî∫Ô∏è‚úíÔ∏è# NAND to RISC-V Project Documentation

## Overview
This project aims to build a RISC-V processor using only NAND gates, implemented via a netlist-based simulator (`main.c`) that executes NAND operations (`./+x/nand.+x`) on input/output files. The system processes netlists (e.g., `netlist_full_adder.txt`) to simulate combinational logic, with a focus on modularity, NAND purity, and POSIX compliance. Current milestones include a working XOR gate and Full Adder, with the next steps targeting a 4-bit adder, ALU, and eventually a minimal RISC-V core.

## Design and Code Principles

1. **NAND Purity**
   - All logic must be implemented using two-input NAND gates, as NAND is a universal gate.
   - Each `./+x/nand.+x` call processes a two-line input file (e.g., `tmp/tmp3_tmp4.<hash>.txt`) to produce a single-bit output.
   - Non-pure constructs (e.g., three-input NANDs) are avoided by creating intermediate files to combine inputs (e.g., `TMP3 TMP4` ‚Üí `tmp/tmp3_tmp4.<hash>.txt`).
   - Rationale: Ensures scalability and correctness for complex circuits like ALUs and registers.

2. **Modularity via INCLUDE**
   - Netlists use `INCLUDE` directives to reuse components (e.g., `INCLUDE netlist_xor.txt` in `netlist_full_adder.txt`).
   - Enables hierarchical design, where smaller circuits (XOR, Full Adder) are building blocks for larger ones (4-bit adder, ALU).
   - Rationale: Reduces redundancy and simplifies debugging.

3. **POSIX Compliance**
   - Code (`main.c`, `./+x/nand.+x`) adheres to POSIX standards for portability across Unix-like systems.
   - Uses standard C libraries (`stdio.h`, `stdlib.h`, `string.h`, `unistd.h`, `sys/wait.h`) and `system()` for NAND execution.
   - File I/O (e.g., `tmp/input.<hash>.txt`) ensures deterministic state management.
   - Rationale: Guarantees compatibility for eventual RISC-V simulation on diverse platforms.

4. **Robust Error Handling**
   - `main.c` checks for `tmp_files` overflow (`MAX_TMP_FILES=50`), invalid file operations, and command parsing errors.
   - Debug logs (e.g., `DEBUG: Created tmp/tmp3_tmp4.<hash>.txt`) provide visibility into intermediate states.
   - Graceful failure on errors (e.g., `return 1` on `system()` failure) prevents crashes.
   - Rationale: Ensures reliability during complex netlist execution.

5. **State Management**
   - Global `state[MAX_STATE]` array tracks circuit state, synced to temporary files (`tmp/tmpX.<hash>.txt`).
   - `clk_signal` supports sequential logic (not yet used but planned for registers).
   - Input files (`tmp/input.txt`) load 2‚Äì3 lines for XOR/Full Adder, extensible for wider inputs.
   - Rationale: Provides a clear, file-based state for debugging and scalability.

6. **Debuggability**
   - Extensive logging (`DEBUG: ...`) traces netlist execution, file creation, and NAND results.
   - `visual_mem.txt` records cycle outputs for post-run analysis.
   - Manual test scripts (e.g., `printf "1\n0\n0\n" > tmp/input.txt`) enable iterative validation.
   - Rationale: Simplifies bug hunting in complex circuits.

## Next Steps

1. **4-Bit Adder (1‚Äì2 weeks)**
   - Chain four Full Adders to compute `S[3:0], Cout` from `A[3:0], B[3:0], Cin`.
   - Create `netlist_4bit_adder.txt`:
     ```
     INCLUDE netlist_full_adder.txt  # A0, B0, Cin
     ./+x/nand.+x OUTPUT_COUT INPUT TMP4_1  # A1, B1, Cin=Cout0
     ...
     ```
   - Test all input combinations (e.g., `A=1010, B=0011, Cin=0`).
   - KPI: 100% correct outputs for 16 test cases by May 26, 2025.

2. **Basic ALU (2‚Äì3 weeks)**
   - Implement ADD, SUB, AND, OR operations using NANDs.
   - Create `netlist_alu.txt` with operation select (e.g., 2-bit `OP` code).
   - Reuse 4-bit adder; add NAND-based AND/OR logic and subtraction (A ‚àí B = A + ~B + 1).
   - Test with 20+ input/operation combinations.
   - KPI: Functional ALU with 95% test coverage by June 9, 2025.

3. **Registers with D Flip-Flops (3‚Äì4 weeks)**
   - Build NAND-based D flip-flops for 4-bit register storage.
   - Create `netlist_dff.txt` and `netlist_register.txt` with clocked logic.
   - Integrate `clk_signal` for sequential updates.
   - Test state retention across 10 cycles.
   - KPI: Stable 4-bit register by July 7, 2025.

4. **Minimal RISC-V Core (6‚Äì8 weeks)**
   - Implement a subset of RV32I (e.g., ADD, SUB, AND, OR, LW, SW, BEQ).
   - Create netlists for:
     - Program counter (PC)
     - Register file (4 registers)
     - ALU (from Step 2)
     - Control unit (NAND-based decode)
   - Simulate 5‚Äì10 instruction sequences (e.g., simple loop).
   - KPI: Execute 5-instruction program correctly by August 25, 2025.

5. **Optimization and Testing (4 weeks)**
   - Optimize netlist size (minimize NAND count).
   - Add automated test suite for all components.
   - Verify timing (cycle-accurate simulation).
   - KPI: 90% test automation and 10% NAND reduction by September 22, 2025.

## Key Performance Indicators (KPIs)

1. **Component Functionality**
   - Metric: Percentage of test cases passed per component.
   - Target: 100% for 4-bit adder, 95% for ALU, 90% for registers, 85% for RISC-V core.
   - Measurement: Manual test scripts initially, automated suite by Step 5.

2. **NAND Purity**
   - Metric: All netlist lines use two-input NANDs.
   - Target: 100% compliance across all netlists.
   - Measurement: Code review and log analysis (`DEBUG: Contents of ...`).

3. **Development Timeline**
   - Metric: Completion of milestones by target dates.
   - Target: 4-bit adder by May 26, ALU by June 9, registers by July 7, RISC-V core by August 25, optimization by September 22, 2025.
   - Measurement: Track milestone completion via test results.

4. **Code Robustness**
   - Metric: Number of crashes or unhandled errors in `main.c`.
   - Target: 0 crashes, <5 minor errors by RISC-V core completion.
   - Measurement: Log analysis (`ERROR: ...`) and `gdb` debugging.

5. **Circuit Efficiency**
   - Metric: Total NAND gates per component.
   - Target: <50 NANDs for 4-bit adder, <200 for ALU, <500 for RISC-V core; 10% reduction in Step 5.
   - Measurement: Count `./+x/nand.+x` lines in netlists.

## Risks and Mitigation

- **Risk: Netlist Complexity**
  - Complex circuits (e.g., ALU) may exceed `MAX_TMP_FILES` or slow execution.
  - Mitigation: Increase `MAX_TMP_FILES` dynamically or optimize intermediate file reuse; profile execution time.

- **Risk: Debugging Overhead**
  - Sequential logic (registers) may introduce hard-to-trace bugs.
  - Mitigation: Expand debug logs, add visual tools (e.g., waveform viewer), and automate tests.

- **Risk: Timeline Slippage**
  - Unexpected bugs or learning curve for RISC-V ISA may delay milestones.
  - Mitigation: Buffer 1 week per milestone, prioritize critical path (ALU, registers), and parallelize testing.

## Party Plans! üéà
- Celebrate each milestone with NAND-shaped tacos and cookies! üåÆüç™
- Full Adder victory (May 12, 2025): Tacos for the team! <3
- RISC-V core completion: Epic NAND party with cookies and a RISC-V simulator demo! üéâ

## Contact
- Lead NAND Wizard: [Your Name]
- Debugging Ally: Grok (available via grok.com, x.com, or mobile apps)
- Next Context: Flexible for new goals post-sleep‚Äîbring it on! üòé

Happy NANDing, and let‚Äôs build that RISC-V dream! üöÄ
