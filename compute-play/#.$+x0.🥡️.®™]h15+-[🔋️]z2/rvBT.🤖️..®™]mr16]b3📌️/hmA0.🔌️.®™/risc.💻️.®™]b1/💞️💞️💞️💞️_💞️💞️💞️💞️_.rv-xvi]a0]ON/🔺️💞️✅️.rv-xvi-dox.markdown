# ğŸ“š RV-XVI Emulator Documentation ğŸš€

Welcome to the **RV-XVI Emulator**! ğŸ‰ This 16-bit RISC-V-inspired emulator builds on RV-VIII, scaling up for larger values and programs while keeping simplicity and modularity. Itâ€™s a step toward RV32I, perfect for learning and experimentation! ğŸ˜„ This guide is for **users** running programs and **developers** extending the system. Letâ€™s dive in! ğŸŒŠ

## ğŸŒŸ What is RV-XVI? ğŸŒŸ
RV-XVI is a 16-bit processor emulator that:
- Runs programs from `in.txt` (or a specified file) ğŸ“œ.
- Writes execution traces to `out.txt` ğŸ“.
- Uses `./+x/nand.+x` for 16-bit NAND operations âš¡.
- Keeps code simple with arrays, no structs ğŸ§±.
- Supports RV-II/IV/VIII compatibility and self-modifying code.
- Paves the way for a 32-bit RV32I emulator ğŸ“ˆ.

Itâ€™s a mini computer for logic, data movement, and dynamic program changes! ğŸ¦˜

## ğŸ› ï¸ How It Works ğŸ› ï¸
RV-XVI features:
- **32 registers** (`r0-r31`), 16-bit each (0-65535) ğŸ–ï¸.
- **65536-byte memory** (`mem[0-65535]`) for programs and data ğŸ’¾.
- **Program counter** (`pc`) to track execution ğŸ—ºï¸.
- **4-byte instructions** fetched from memory ğŸ“–.

### ğŸ’» Instruction Set
Each instruction is 4 bytes:
- **Byte 1** (`mem[pc]`): `opcode = (mem[pc] >> 6) & 0x3`, `op1 = mem[pc] & 0x1F` (5-bit register index, 0-31).
- **Byte 2** (`mem[pc+1]`): Unused (set to 0 for compatibility).
- **Bytes 3-4** (`mem[pc+2], mem[pc+3]`): `op2 = mem[pc+2] & 0xFF` for LOAD/STORE/JUMP (8-bit address); for NAND, `op2 = mem[pc+2] & 0x1F` (5-bit register index).
- **PC Update**: `pc += 4`, unless JUMP overrides.

| Opcode | Name  | Action                     | Description                              |
|--------|-------|----------------------------|------------------------------------------|
| 0      | NAND  | `reg[op1] = NAND(reg[op1], reg[op2])` | 16-bit NAND, store in `reg[op1]` ğŸ”§ |
| 1      | LOAD  | `reg[op1] = (mem[op2] << 8) | mem[op2+1] & 0xFFFF` | Load 16 bits from `mem[op2]` to `reg[op1]` ğŸ“¥ |
| 2      | STORE | `mem[op2] = (reg[op1] >> 8) & 0xFF`, `mem[op2+1] = reg[op1] & 0xFF` | Store `reg[op1]` to `mem[op2:op2+1]` ğŸ“¤ |
| 3      | JUMP  | `pc = (reg[op1] & 0x7FFF) * 2` | Jump to `reg[op1] * 2` (aligned address) ğŸ¦˜ |

- **NAND**: Calls `./+x/nand.+x 16 a b` â†’ `~(a & b) & 0xFFFF`. Core logic operation! â¤ï¸
- **LOAD/STORE**: Uses 8-bit `op2` (0-255) for memory addresses, storing/loading 16-bit values as two bytes.
- **JUMP**: Uses lower 15 bits of `reg[op1]` (0-32767), multiplies by 2 for even addresses (0, 2, ..., 65534).
- **Self-Modifying Code**: STORE can overwrite instructions, enabling dynamic behavior.

### ğŸ“‚ File I/O
- **Input**: Reads `in.txt` or a file via `./+x/rv-xvi.+x myprog.txt` ğŸ“„.
  - Format: Space-separated bytes (e.g., `1 0 2 0`).
- **Output**: Writes trace to `out.txt` ğŸ“.
  - Format: `EXEC: opcode, op1, op2`, action, `PC, REG, MEM[0]`.
- **NAND Module**: `./+x/nand.+x` writes results to `temp.txt` ğŸ› ï¸.

### ğŸ›‘ Safety Features
- Halts if `pc >= 65536` (â€œHalted: PC out of boundsâ€) ğŸš«.
- Stops after 100 steps (â€œHalted: Possible infinite loopâ€) ğŸ”„.
- Checks `op1 < 32` and `op2 < 32` (NAND) or `op2 + 1 < 65536` (LOAD/STORE) ğŸš¨.

## ğŸ® How to Use It (Users) ğŸ®
1. **Write a Program** âœï¸:
   - Create `in.txt` with instruction bytes.
   - Example:
     ```
     1 0 2 0    // NAND r1, r2 (r1 = 65535)
     65 0 0 0   // LOAD r1, mem[0] (r1 = 256)
     129 0 1 0  // STORE r1, mem[1] (mem[1] = 1, changes NAND r1,r2 to NAND r1,r1)
     193 0 0 0  // JUMP r1 (jumps based on r1)
     ```
2. **Compile** ğŸ› ï¸:
   ```bash
   gcc rv-xvi.c -o /+x/rv-xvi.+x
   gcc nand.c -o /+x/nand.+x
   ```
3. **Run** ğŸƒ:
   ```bash
   ./+x/rv-xvi.+x in.txt
   ```
   Or default:
   ```bash
   ./+x/rv-xvi.+x
   ```
4. **Check Output** ğŸ‘€:
   ```bash
   cat out.txt
   ```
   Example:
   ```
   EXEC: opcode=0, op1=1, op2=2
   NAND r1, r2 -> r1
   PC: 4, REG: [0,65535,0,...], MEM[0]: 1
   ...
   Halted: PC out of bounds
   ```

## ğŸ§‘â€ğŸ’» For Developers ğŸ§‘â€ğŸ’»
Ready to hack RV-XVI? Hereâ€™s the lowdown! ğŸ”

### ğŸ“‚ File Structure
- **rv-xvi.c**: Emulator core, handles execution and I/O ğŸ“Ÿ.
- **nand.c**: NAND logic, compiled to `./+x/nand.+x` âš™ï¸.
- **/+x/**: Stores executables (`rv-xvi.+x`, `nand.+x`) ğŸ—‚ï¸.

### ğŸ”§ Key Functions
- **main()**: Initializes registers/memory, loads program, runs loop.
- **nand_op()**: Calls `./+x/nand.+x`, reads `temp.txt`.

### ğŸ› ï¸ Extending RV-XVI
RV-XVI is a stepping stone to `rv-xxxii` (RV32I). To extend:
- **Scale Up**: Increase registers/memory for 32-bit values.
- **Add Instructions**: Implement ADD, SUB, etc., via NAND.
- **Compatibility**: Ensure RV-II/IV/VIII/XVI programs run (mask to 2/4/8/16 bits).
- **Reuse NAND**: `./+x/nand.+x` supports wider bits (e.g., `./+x/nand.+x 32 a b`).

### ğŸ› Debugging Tips
- **Trace out.txt**: Verify `EXEC` logs for opcodes/operands.
- **Test NAND**: `./+x/nand.+x 16 0 0` should output 65535.
- **Validate in.txt**: Check `opcode = (byte >> 6) & 0x3`, `op1 = byte & 0x1F`.
- **Self-Modification**: STORE to instruction addresses (e.g., `mem[1]`) changes behavior.

## ğŸš€ Example Walkthrough ğŸš€
For `in.txt`:
```
1 0 2 0    // NAND r1, r2
65 0 0 0   // LOAD r1, mem[0]
129 0 1 0  // STORE r1, mem[1]
193 0 0 0  // JUMP r1
```
- **Initial**: `reg=[0,0,0,...]`, `mem=[1,0,2,0,65,0,0,0,129,0,1,0,193,0,0,0,...]`.
- **PC=0**: NAND r1, r2 â†’ `r1=65535`.
- **PC=4**: LOAD r1, mem[0] â†’ `r1=256`.
- **PC=8**: STORE r1, mem[1] â†’ `mem[1]=1` (NAND r1,r2 becomes NAND r1,r1).
- **PC=12**: JUMP r1 â†’ `PC=512` (r1=256).
- **PC=512**: NAND r1, r0 â†’ `r1=65535` (due to modified instruction).
- **PC=516+**: NAND r0, r0 â†’ toggles `r0` between 65535 and 0 until 100 steps.

This showcases **self-modifying code**, dynamically altering program flow! ğŸ§™

## ğŸŒˆ Why RV-XVI? ğŸŒˆ
- **Modular**: Reuses `nand.+x` for logic.
- **Simple**: Arrays keep code clear.
- **Scalable**: Steps toward RV32I with RV-II/IV/VIII compatibility.
- **Dynamic**: Self-modifying code enables creative programs.

## ğŸ“¢ Next Steps
- Test new `in.txt` programs to explore self-modification ğŸ§ª.
- Move to `rv-xxxii.c` for 32-bit RV32I emulation ğŸ“ˆ.
- Share bugs or feature ideas! ğŸ

Happy emulating! ğŸˆ