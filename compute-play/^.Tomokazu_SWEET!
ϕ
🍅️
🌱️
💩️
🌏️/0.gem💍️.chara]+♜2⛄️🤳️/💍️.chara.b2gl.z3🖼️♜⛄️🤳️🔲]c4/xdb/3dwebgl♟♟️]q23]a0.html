<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>3D Chess Game (WebGL)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #menu, #inventory {
            position: absolute;
            top: 50px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="hud"></div>
    <div id="menu"></div>
    <div id="inventory"></div>
    <div id="controls">
        <button onclick="resetGame()">Reset Game</button>
        <button onclick="toggleView()">Toggle 2D/3D</button>
    </div>
    <script>
        const BOARD_SIZE = 8;
        const MAX_INVENTORY = 5;
        const gameState = {
            board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null))),
            playerBoard: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0))),
            currentTurn: 1,
            cursorX: 0, cursorY: 0, cursorZ: 0,
            selectedX: -1, selectedY: -1, selectedZ: -1,
            inMenu: false,
            menuSelection: 0,
            showInventory: false,
            inventory: [],
            player1Timer: 300,
            player2Timer: 300,
            gameOver: false,
            winner: 0,
            message: '',
            messageExpire: 0
        };
        let scene, camera, renderer, controls, cursorMesh;
        let is2DView = false;

        // Initialize Three.js
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera.position.set(15, 15, 15);
            camera.lookAt(BOARD_SIZE / 2, BOARD_SIZE / 2, BOARD_SIZE / 2);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            // Initialize board
            readBoardState();
            drawBoard();
            drawCursor();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            animate();
        }

        // Create emoji texture
        function createEmojiTexture(emoji) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = '48px "Noto Color Emoji", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // Draw board
        function drawBoard() {
            scene.children = scene.children.filter(child => child === cursorMesh || child instanceof THREE.AmbientLight || child instanceof THREE.DirectionalLight);
            const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const material = new THREE.MeshPhongMaterial({ color: 0x888888 });

            // Draw grid
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x555555 });
            for (let z = 0; z <= BOARD_SIZE; z++) {
                for (let i = 0; i <= BOARD_SIZE; i++) {
                    const points = [];
                    points.push(new THREE.Vector3(i, 0, z));
                    points.push(new THREE.Vector3(i, BOARD_SIZE, z));
                    scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), lineMaterial));
                    points.length = 0;
                    points.push(new THREE.Vector3(0, i, z));
                    points.push(new THREE.Vector3(BOARD_SIZE, i, z));
                    scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), lineMaterial));
                    points.length = 0;
                    points.push(new THREE.Vector3(0, i, z));
                    points.push(new THREE.Vector3(BOARD_SIZE, i, z));
                    scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), lineMaterial));
                }
            }

            // Draw pieces
            for (let z = 0; z < BOARD_SIZE; z++) {
                for (let y = 0; y < BOARD_SIZE; y++) {
                    for (let x = 0; x < BOARD_SIZE; x++) {
                        if (gameState.board[z][y][x]) {
                            const emoji = gameState.board[z][y][x];
                            const texture = createEmojiTexture(emoji);
                            const materials = [
                                new THREE.MeshPhongMaterial({ color: 0x888888 }), // right
                                new THREE.MeshPhongMaterial({ color: 0x888888 }), // left
                                new THREE.MeshPhongMaterial({ color: 0x888888 }), // top
                                new THREE.MeshPhongMaterial({ color: 0x888888 }), // bottom
                                new THREE.MeshPhongMaterial({ map: texture }), // front
                                new THREE.MeshPhongMaterial({ color: 0x888888 })  // back
                            ];
                            const cube = new THREE.Mesh(cubeGeometry, materials);
                            cube.position.set(x + 0.5, y + 0.5, z + 0.5);
                            scene.add(cube);
                            console.log(`Rendering piece '${emoji}' at (${x}, ${y}, ${z}) for player ${gameState.playerBoard[z][y][x]}`);
                        }
                    }
                }
            }
        }

        // Draw cursor
        function drawCursor() {
            if (cursorMesh) scene.remove(cursorMesh);
            const geometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 });
            cursorMesh = new THREE.Mesh(geometry, material);
            cursorMesh.position.set(gameState.cursorX + 0.5, gameState.cursorY + 0.5, gameState.cursorZ + 0.5);
            scene.add(cursorMesh);
        }

        // Parse 1rst_render_debug.txt
        async function readFirstRenderDebug() {
            try {
                const response = await fetch('1rst_render_debug.txt');
                if (!response.ok) {
                    console.log('Warning: 1rst_render_debug.txt not found, falling back to board_state.txt');
                    return false;
                }
                const text = await response.text();
                const lines = text.split('\n');
                let y = 7; // Row A = y=7
                let pieceCount = 0;
                console.log('Reading 1rst_render_debug.txt for z=0 layer');
                for (const line of lines) {
                    if (line.includes('+-----') || line.includes('0      1      2')) continue;
                    if (line.startsWith('A|') || line.startsWith('B|') || line.startsWith('C|') || 
                        line.startsWith('D|') || line.startsWith('E|') || line.startsWith('F|') || 
                        line.startsWith('G|') || line.startsWith('H|')) {
                        const cells = line.split('|').slice(1, 9).map(cell => cell.trim());
                        let x = 0;
                        for (const cell of cells) {
                            if (cell && cell !== '' && cell !== ' ') {
                                gameState.board[0][y][x] = cell;
                                gameState.playerBoard[0][y][x] = y >= 4 ? 1 : 2;
                                pieceCount++;
                                console.log(`Loaded piece '${cell}' at (${x}, ${y}, 0) for player ${gameState.playerBoard[0][y][x]}`);
                            } else {
                                gameState.board[0][y][x] = null;
                                gameState.playerBoard[0][y][x] = 0;
                            }
                            x++;
                        }
                        y--;
                    }
                }
                console.log(`Total pieces loaded from 1rst_render_debug.txt: ${pieceCount}`);
                return true;
            } catch (e) {
                console.log(`Error reading 1rst_render_debug.txt: ${e}, falling back to board_state.txt`);
                return false;
            }
        }

        // Parse board_state.txt (simplified fallback)
        async function readBoardStateFile() {
            try {
                const response = await fetch('board_state.txt');
                if (!response.ok) throw new Error('board_state.txt not found');
                const text = await response.text();
                const lines = text.split('\n');
                let z = 0, pieceCount = 0;
                console.log('Reading board_state.txt');
                for (const line of lines) {
                    if (line.trim() === '') continue;
                    const rows = line.split(' ');
                    let y = 0;
                    for (const row of rows) {
                        const cells = row.split(',');
                        let x = 0;
                        for (const cell of cells) {
                            if (cell !== 'none') {
                                gameState.board[z][y][x] = cell; // Use piece name as symbol
                                gameState.playerBoard[z][y][x] = z < 4 ? 1 : 2;
                                pieceCount++;
                                console.log(`Loaded piece '${cell}' at (${x}, ${y}, ${z}) for player ${gameState.playerBoard[z][y][x]}`);
                            }
                            x++;
                        }
                        y++;
                    }
                    z++;
                }
                console.log(`Total pieces loaded from board_state.txt: ${pieceCount}`);
                return true;
            } catch (e) {
                console.error(`Error reading board_state.txt: ${e}`);
                return false;
            }
        }

        // Initialize board state
        async function readBoardState() {
            if (await readFirstRenderDebug()) {
                for (let z = 1; z < BOARD_SIZE; z++) {
                    for (let y = 0; y < BOARD_SIZE; y++) {
                        for (let x = 0; x < BOARD_SIZE; x++) {
                            gameState.board[z][y][x] = null;
                            gameState.playerBoard[z][y][x] = 0;
                        }
                    }
                }
            } else {
                await readBoardStateFile();
            }
            drawBoard();
        }

        // Update HUD
        function updateHUD() {
            const hud = document.getElementById('hud');
            hud.innerHTML = `Turn: Player ${gameState.currentTurn} | P1: ${Math.round(gameState.player1Timer)}s | P2: ${Math.round(gameState.player2Timer)}s`;
            if (gameState.message && Date.now() / 1000 < gameState.messageExpire) {
                hud.innerHTML += `<br>${gameState.message}`;
            } else {
                gameState.message = '';
            }
            if (gameState.gameOver) {
                hud.innerHTML += `<br>GAME OVER! Player ${gameState.winner} wins!`;
            }
            const menu = document.getElementById('menu');
            if (gameState.inMenu) {
                const opts = ['Stats', 'Move', 'Items', 'Attack'];
                menu.innerHTML = opts.map((opt, i) => 
                    `${i === gameState.menuSelection ? '[' : ' '}${opt}${i === gameState.menuSelection ? ']' : ''}`).join(' ');
            } else {
                menu.innerHTML = '';
            }
            const inventory = document.getElementById('inventory');
            if (gameState.showInventory) {
                inventory.innerHTML = 'Inventory:<br>' + gameState.inventory.map(item => 
                    `  * ${item.name} (${item.type === 'potion' ? 'heals' : 'dmg'} ${item.value})`).join('<br>');
            } else {
                inventory.innerHTML = '';
            }
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Keyboard handler
        function onKeyDown(event) {
            if (gameState.gameOver) return;
            switch (event.key) {
                case 'w': case 'W':
                    camera.position.z -= 0.5;
                    if (camera.position.z < 5) camera.position.z = 5;
                    break;
                case 's': case 'S':
                    camera.position.z += 0.5;
                    if (camera.position.z > 30) camera.position.z = 30;
                    break;
                case 'a': case 'A':
                    camera.position.x -= 0.5;
                    break;
                case 'd': case 'D':
                    camera.position.x += 0.5;
                    break;
                case 'q': case 'Q':
                    camera.position.y += 0.5;
                    if (camera.position.y > 20) camera.position.y = 20;
                    break;
                case 'e': case 'E':
                    camera.position.y -= 0.5;
                    if (camera.position.y < -20) camera.position.y = -20;
                    break;
                case 'ArrowLeft':
                    if (gameState.inMenu) {
                        if (gameState.menuSelection > 0) gameState.menuSelection--;
                    } else if (gameState.cursorX > 0) {
                        gameState.cursorX--;
                    }
                    break;
                case 'ArrowRight':
                    if (gameState.inMenu) {
                        if (gameState.menuSelection < 3) gameState.menuSelection++;
                    } else if (gameState.cursorX < BOARD_SIZE - 1) {
                        gameState.cursorX++;
                    }
                    break;
                case 'ArrowUp':
                    if (!gameState.inMenu && gameState.cursorY > 0) {
                        gameState.cursorY--;
                    }
                    break;
                case 'ArrowDown':
                    if (!gameState.inMenu && gameState.cursorY < BOARD_SIZE - 1) {
                        gameState.cursorY++;
                    }
                    break;
                case 'c': case 'C':
                    if (!gameState.inMenu && gameState.cursorZ < BOARD_SIZE - 1) {
                        gameState.cursorZ++;
                    }
                    break;
                case 'v': case 'V':
                    if (!gameState.inMenu && gameState.cursorZ > 0) {
                        gameState.cursorZ--;
                    }
                    break;
                case 'Escape':
                    if (gameState.selectedX !== -1 || gameState.selectedY !== -1 || gameState.selectedZ !== -1) {
                        gameState.selectedX = gameState.selectedY = gameState.selectedZ = -1;
                        gameState.message = 'Selection cancelled';
                        gameState.messageExpire = Date.now() / 1000 + 1;
                    } else if (gameState.inMenu) {
                        gameState.inMenu = false;
                    } else if (gameState.showInventory) {
                        gameState.showInventory = false;
                    }
                    break;
                case 'Enter':
                    if (gameState.inMenu) {
                        if (gameState.menuSelection === 2) { // Items
                            gameState.showInventory = !gameState.showInventory;
                            gameState.inventory = []; // Simplified: no inventory for 1rst_render_debug.txt
                        } else if (gameState.menuSelection === 1) { // Move
                            if (!gameState.board[gameState.cursorZ][gameState.cursorY][gameState.cursorX]) {
                                const fromX = gameState.selectedX, fromY = gameState.selectedY, fromZ = gameState.selectedZ;
                                const toX = gameState.cursorX, toY = gameState.cursorY, toZ = gameState.cursorZ;
                                gameState.board[toZ][toY][toX] = gameState.board[fromZ][fromY][fromX];
                                gameState.playerBoard[toZ][toY][toX] = gameState.playerBoard[fromZ][fromY][fromX];
                                gameState.board[fromZ][fromY][fromX] = null;
                                gameState.playerBoard[fromZ][fromY][fromX] = 0;
                                gameState.message = `Moved piece to ${String.fromCharCode(65 + toY)}${toX}${toZ}`;
                                gameState.messageExpire = Date.now() / 1000 + 2;
                                gameState.currentTurn = gameState.currentTurn === 1 ? 2 : 1;
                                gameState.selectedX = gameState.selectedY = gameState.selectedZ = -1;
                                gameState.inMenu = false;
                                drawBoard();
                            } else {
                                gameState.message = 'Target occupied!';
                                gameState.messageExpire = Date.now() / 1000 + 2;
                            }
                        }
                    } else if (gameState.selectedX === -1 && gameState.selectedY === -1 && gameState.selectedZ === -1) {
                        if (gameState.board[gameState.cursorZ][gameState.cursorY][gameState.cursorX] &&
                            gameState.playerBoard[gameState.cursorZ][gameState.cursorY][gameState.cursorX] === gameState.currentTurn) {
                            gameState.selectedX = gameState.cursorX;
                            gameState.selectedY = gameState.cursorY;
                            gameState.selectedZ = gameState.cursorZ;
                            gameState.inMenu = true;
                            gameState.menuSelection = 0;
                            gameState.message = `Selected piece`;
                            gameState.messageExpire = Date.now() / 1000 + 2;
                        } else {
                            gameState.message = 'Can\'t select that piece';
                            gameState.messageExpire = Date.now() / 1000 + 2;
                        }
                    }
                    break;
            }
            drawCursor();
            updateHUD();
        }

        // Toggle 2D/3D view
        function toggleView() {
            is2DView = !is2DView;
            if (is2DView) {
                camera.position.set(BOARD_SIZE / 2, BOARD_SIZE / 2, 15);
                camera.lookAt(BOARD_SIZE / 2, BOARD_SIZE / 2, 0);
                controls.enabled = false;
            } else {
                camera.position.set(15, 15, 15);
                camera.lookAt(BOARD_SIZE / 2, BOARD_SIZE / 2, BOARD_SIZE / 2);
                controls.enabled = true;
            }
        }

        // Reset game
        function resetGame() {
            gameState.currentTurn = 1;
            gameState.cursorX = gameState.cursorY = gameState.cursorZ = 0;
            gameState.selectedX = gameState.selectedY = gameState.selectedZ = -1;
            gameState.inMenu = false;
            gameState.showInventory = false;
            gameState.player1Timer = 300;
            gameState.player2Timer = 300;
            gameState.gameOver = false;
            gameState.message = '';
            readBoardState();
            drawCursor();
            updateHUD();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (!gameState.gameOver) {
                if (gameState.currentTurn === 1) {
                    gameState.player1Timer -= 1 / 60;
                    if (gameState.player1Timer <= 0) {
                        gameState.gameOver = true;
                        gameState.winner = 2;
                    }
                } else {
                    gameState.player2Timer -= 1 / 60;
                    if (gameState.player2Timer <= 0) {
                        gameState.gameOver = true;
                        gameState.winner = 1;
                    }
                }
            }
            controls.update();
            renderer.render(scene, camera);
            updateHUD();
        }

        // Start the game
        init();
    </script>
</body>
</html>