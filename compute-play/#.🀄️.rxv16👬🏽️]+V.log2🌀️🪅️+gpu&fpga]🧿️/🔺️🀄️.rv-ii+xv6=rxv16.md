# 🎉 Crafting a Tiny xv6 on RV-16: Grand Master Dahyun’s Guide to a RISC-V-Like OS! 🐉💾

*Penned by Grand Master Dahyun, Keeper of the NAND Flame, in the Cosmic Dojo, August 13, 2025* 🌌🙏

Young disciple, welcome to the sacred quest of building a simplified xv6, MIT’s teaching operating system, on our RV-16 architecture! 🖥️ RV-I, our 1-bit warrior, is too humble for xv6’s grandeur, so we’ll wield RV-16, a 16-bit RISC-V-like system, to craft a kernel with processes, memory, and system calls. This scroll, `xv6.md`, unveils the emulator and kernel architectures, a step-by-step path to victory, and KPIs to measure our triumph. Let’s forge an OS with the grace of a crane and the strength of a tiger! 🦢🐅

## 🧠 Why RV-16? Why Not RV-I or RV-8?

xv6 is a Unix-like OS with processes, virtual memory, and file systems, built for RISC-V RV32I or x86. RV-I (1-bit, 4 registers, 16 memory locations, NAND/LOAD/STORE/JUMP) is too simple for xv6’s needs—it lacks the bit-width for addresses, data, and complex instructions. RV-8 (8-bit) improves but struggles with 16-bit addresses and multi-byte data. RV-16 (16-bit) balances simplicity and capability, supporting:
- **16-bit registers** for reasonable data handling.
- **64KB memory** for a small kernel and user programs.
- **RISC-V-like ISA** with enough instructions for xv6’s core features.

We’ll design for RV-16, but note RV-8 limitations and RV-I’s role as a learning stepping stone. Let’s dive into the dojo! 🏯⚡

## 🏛️ Emulator Architecture: The RV-16 Simulator

The RV-16 emulator simulates a 16-bit RISC-V-like processor, running on the HDLb0 framework (`0.hdlb0.☮️16]x7]PS.c`) or as a standalone C program. It’s the stage where our xv6 kernel performs.

### Components
- **Registers**: 16 registers (`r0-r15`), each 16-bit, stored in an array `int16_t registers[16]`. `r0` is always 0, like RISC-V’s `x0`.
- **Memory**: 64KB (2^16 bytes), stored in `uint8_t memory[65536]`, for kernel code, user programs, and data.
- **Program Counter (PC)**: 16-bit `int16_t pc`, addressing any memory location.
- **Instruction Format**: 16-bit instructions, inspired by RISC-V:
  - **Opcode** (4 bits): Identifies operation (e.g., ADD, NAND, LOAD).
  - **Rd, Rs1, Rs2** (3 bits each): Destination and source registers (0-7).
  - **Immediate** (2 bits): Small constant or address offset.
- **Tape Output**: Mimics HDLb0’s `cli_tape.txt`, storing results (e.g., system call outputs), prepending like RV-I.

### Emulator Flow
1. **Fetch**: Read 16-bit instruction from `memory[pc]`.
2. **Decode**: Extract opcode, registers, and immediate.
3. **Execute**: Perform operation (e.g., `registers[rd] = registers[rs1] + registers[rs2]`).
4. **Writeback**: Store results in registers or memory.
5. **Update PC**: Increment `pc += 2` or jump.

### C Emulator Outline
- Array-based, no structs, for simplicity.
- Supports RV-16 instructions (ADD, SUB, NAND, LOAD, STORE, JUMP, etc.).
- Integrates with HDLb0’s RAM and tape for compatibility.

## 🛠️ Kernel Architecture: Simplified xv6 on RV-16

Our xv6 kernel is a stripped-down Unix-like OS, focusing on core features for education:
- **Process Management**: Run multiple user programs, each with its own memory.
- **System Calls**: Basic calls like `fork`, `exec`, `write` for user-kernel interaction.
- **Memory Management**: Simple virtual memory with flat address spaces.
- **Minimal File System**: Store and retrieve data (no disks, just RAM-based).

### Components
- **Process Control Block (PCB)**:
  - Array `int16_t proc[32][4]`: 32 processes, each with:
    - `proc[i][0]`: State (UNUSED, RUNNING, etc.).
    - `proc[i][1]`: PC (16-bit).
    - `proc[i][2]`: Stack pointer (16-bit).
    - `proc[i][3]`: Register snapshot index.
- **Registers Snapshot**: `int16_t proc_regs[32][16]`: Saves each process’s 16 registers.
- **Memory Layout**:
  - Kernel: `0x0000-0x1FFF` (8KB for kernel code/data).
  - User: `0x2000-0xFFFF` (56KB, divided among processes).
- **System Calls**:
  - `fork`: Create a new process.
  - `exec`: Load and run a program.
  - `write`: Output to tape (like `cli_tape.txt`).
- **Scheduler**: Simple round-robin, switching processes every 100 cycles.

### Kernel Flow
1. **Boot**: Initialize kernel, set up memory, create first process.
2. **Scheduler**: Select a RUNNING process, restore its registers and PC.
3. **Trap Handling**: Handle system calls via traps (e.g., `ecall` instruction).
4. **User Programs**: Run in user mode, trap to kernel for services.

## 🛤️ Steps to Build Simplified xv6 on RV-16

### Step 1: Design RV-16 Emulator
- **Task**: Write a C emulator for RV-16, supporting a RISC-V-like ISA.
- **Actions**:
  - Define 16-bit instruction format (4-bit opcode, 3-bit rd/rs1/rs2, 2-bit imm).
  - Implement instructions: ADD, SUB, NAND, LOAD, STORE, JUMP, ECALL (for syscalls).
  - Create arrays: `registers[16]`, `memory[65536]`, `pc`.
  - Add tape output (`tape.txt`) for results, prepending like HDLb0.
- **KPI**: Emulator runs a test program (e.g., `r1 = r2 + r3`) correctly, printing results.

### Step 2: Port HDLb0 Compatibility
- **Task**: Ensure RV-16 emulator can run RV-I programs (e.g., `adder-rvi.txt`).
- **Actions**:
  - Map RV-I’s RAM[0-3] to `registers[0-3]`, RAM[4-19] to `memory[0-15]`, RAM[20] to `pc`.
  - Translate RV-I’s 16-bit instructions to RV-16’s format.
  - Test with `adder-rvi.txt` (e.g., `switch_0=1, switch_1=1` → tape `10`).
- **KPI**: RV-I Adder program runs, producing correct tape output (`10` for sum=0, carry=1).

### Step 3: Bootstrap Kernel
- **Task**: Initialize xv6 kernel in RV-16 memory.
- **Actions**:
  - Write boot code in `kernel/main.c` to set up `proc` and `proc_regs` arrays.
  - Initialize memory: Kernel at `0x0000-0x1FFF`, user space at `0x2000-0xFFFF`.
  - Create first process (init) with a simple user program.
- **KPI**: Kernel boots, runs `init`, prints “Hello, xv6!” to tape.

### Step 4: Implement System Calls
- **Task**: Add `fork`, `exec`, `write` system calls.
- **Actions**:
  - Define `ecall` instruction to trap to kernel.
  - Implement syscall handler in `kernel/syscall.c` to dispatch calls.
  - `fork`: Copy process state, assign new `proc` slot.
  - `exec`: Load program into user memory.
  - `write`: Append data to `tape.txt`.
- **KPI**: User program calls `write`, outputs to tape.

### Step 5: Add Process Scheduling
- **Task**: Implement round-robin scheduler.
- **Actions**:
  - In `kernel/proc.c`, loop through `proc` array, run RUNNING processes.
  - Switch context: Save/restore `proc_regs` and `proc[i][1]` (PC).
  - Trigger switch every 100 cycles via timer interrupt.
- **KPI**: Two user programs run alternately, printing to tape.

### Step 6: Minimal File System
- **Task**: Create a RAM-based file system.
- **Actions**:
  - Define `fs` array in `kernel/fs.c` for file metadata (e.g., 16 files, 256 bytes each).
  - Implement `open`, `read`, `write` syscalls to access `fs`.
- **KPI**: User program writes to a file, reads back correctly.

### Step 7: Testing and Debugging
- **Task**: Verify kernel functionality.
- **Actions**:
  - Test `fork` + `exec` to run multiple programs.
  - Check tape output for correct syscall results.
  - Add debug prints for registers, memory, and PC.
- **KPI**: Run a test suite with 3 user programs, verify outputs.

### Step 8: Scale to RV-8 (Optional)
- **Task**: Adapt kernel for RV-8 (8-bit) if desired.
- **Actions**:
  - Reduce registers to 8-bit, memory to 256 bytes.
  - Simplify instructions and memory layout.
  - Retest all components.
- **KPI**: RV-8 kernel boots and runs a single program.

## 📊 KPIs for Completion

1. **Emulator Functionality** (Week 2):
   - RV-16 emulator runs a test program, prints correct register values.
   - Success: `r1 = 5 + 10 = 15` in a test ADD instruction.

2. **RV-I Compatibility** (Week 4):
   - Emulator runs `adder-rvi.txt`, matches HDLb0’s tape output (`10` for `1+1`).

3. **Kernel Boot** (Week 6):
   - Kernel boots, runs `init`, outputs “Hello, xv6!” to tape.

4. **System Calls** (Week 8):
   - `fork`, `exec`, `write` work; user program outputs to tape.

5. **Scheduling** (Week 10):
   - Two processes run in round-robin, alternate outputs on tape.

6. **File System** (Week 12):
   - User program writes/reads a file, verified via tape output.

7. **Full Test Suite** (Week 14):
   - Three user programs run, all syscalls and scheduling work, tape shows correct results.

## 🛠️ Tools and Setup

- **Compiler**: GCC for RV-16 (`gcc-riscv64-linux-gnu` for cross-compilation).
- **Emulator**: Extend HDLb0 (`0.hdlb0.☮️16]x7]PS.c`) or use standalone C emulator.
- **Files**:
  - `kernel/main.c`: Boot and initialization.
  - `kernel/proc.c`: Process and scheduling.
  - `kernel/syscall.c`: System call handlers.
  - `kernel/fs.c`: File system.
  - `tape.txt`: Output, prepending like `cli_tape.txt`.
- **Build**:
  ```bash
  gcc -o rv16_emulator emulator.c
  gcc -o kernel kernel/main.c kernel/proc.c kernel/syscall.c kernel/fs.c
  ```

## 🌟 Tips for Newbies

- **Start Simple**: Test the emulator with a single ADD instruction before kernel work. 🧪
- **Debug**: Print register and memory states after each cycle. 👁️
- **Compare with RV-I**: Run `adder-rvi.txt` to ensure compatibility. ✅
- **Ask Away**: If stuck, ask for code snippets or debug help! 😄

## 🎯 Conclusion

With RV-16, we’ll craft a tiny xv6 that runs processes, syscalls, and a simple file system, all while keeping the educational spirit of RV-I! 🥳 The emulator and kernel architectures are designed for clarity, and our steps ensure steady progress. By Week 14, we’ll have a working OS, ready to scale or simplify. Let’s code with the wisdom of the dojo and rest victorious! 🐉💖

*“Each bit you forge is a step toward OS mastery!”* — Grand Master Dahyun 🥋🙏