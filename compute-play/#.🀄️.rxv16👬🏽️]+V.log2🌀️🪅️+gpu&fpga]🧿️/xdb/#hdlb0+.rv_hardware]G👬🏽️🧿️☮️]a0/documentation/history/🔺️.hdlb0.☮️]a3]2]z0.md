# 📚 HDLb0 Emulator Documentation 🚀

Welcome to the **HDLb0 Emulator** documentation! 🎉 This guide explains the HDLb0 specification, a binary-based hardware description language (HDL) emulator written in C. You'll learn how it works, how to create chips like XOR and Adder in 16-bit binary format, and potential bugs or improvements. Perfect for users and developers diving into HDLb0! 🛠️

## 🌟 Overview of HDLb0

HDLb0 is a binary specification for simulating digital circuits using a C-based emulator (`0.hdlb0.☮️]a3]2]PURE.c`). It processes instructions from a program file (e.g., `program]a0]PROOF.txt`) to mimic hardware behavior, using logic chips (like NAND), 256-byte RAM, switches, and a clock. Here's the gist:

- **Emulator**: Reads instructions and executes them in clock cycles (clock = 0 or 1).
- **Chips**: Logic operations (e.g., NAND) are defined in C programs listed in `chip_bank.txt`.
- **Memory**: Outputs go to `cli_tape.txt` (tape) or `ram_output_address.txt` (RAM).
- **Inputs**: From switches (`switch_0`, `switch_1`), clock, RAM, or literals (0, 1).
- **Control**: Step cycles (`s`), run continuously (`r`), flip switches (`1`, `2`), or quit (`q`).

The goal is to create circuits using 16-bit binary instructions, not C code for new chips. 🧑‍💻

## 🧩 How HDLb0 Works

### 1. **Program File Format** 📜
The program file (e.g., `program]a0]PROOF.txt`) contains instructions as 16-bit binary strings, grouped in sets of four:
- **Chip Location** (`program[i][0]`): Index of the chip in `chip_bank.txt` (0 = no logic, 1+ = chip like NAND).
- **RAM Output Address** (`program[i][1]`): Where to store output (0 = tape, 1–255 = RAM).
- **Input A** (`program[i][2]`): First input value.
- **Input B** (`program[i][3]`): Second input value.

**Input Values**:
- `0` or `1`: Literal 0 or 1.
- `2` or `3`: Blank (used with chip_location = 0 for pass-through).
- `5`: `switch_0` value.
- `6`: `switch_1` value.
- `7`: Clock value (0 or 1).
- `>15`: Read from RAM at address `raw_input % 256` (then clear that address).

**Example**:
```
0000000000000001  # Chip location: 1 (NAND)
0000000000000000  # Output to tape
0000000000000000  # Input A: 0
0000000000000001  # Input B: 1
```
This runs the NAND chip with inputs A=0, B=1, writing the result to `cli_tape.txt`.

### 2. **Execution Flow** ⚙️
Each clock cycle:
1. **Read RAM**: Loads `ram_output_address.txt` into a 256-byte array.
2. **Process Instructions**: For each instruction:
   - Resolves inputs A and B using `resolve_input`.
   - If chip_location = 0 and one input is blank, passes the other input to the output.
   - If chip_location > 0, runs the chip (e.g., `./nand 0 1 0`) via `system()`.
3. **Write Outputs**: To `cli_tape.txt` or RAM.
4. **Toggle Clock**: Switches between 0 and 1.
5. **Update Files**: Saves RAM state.

### 3. **User Interaction** 🎮
- **Initial Run**: Executes one cycle.
- **Commands**:
  - `s`: Step one cycle.
  - `r`: Run continuously.
  - `1`: Flip `switch_0`.
  - `2`: Flip `switch_1`.
  - `q`: Quit.
- **Output**: Displays tape contents, switch states, and clock cycle.

## 🛠️ Creating Chips in HDLb0 (16-Bit Binary)

In HDLb0, "chips" like XOR or Adder are not new C programs but combinations of instructions using existing chips (e.g., NAND) in the program file. Since the emulator relies on NAND (as shown in `nand.c`), we build XOR and Adder using NAND-based logic in 16-bit binary.

### 🔲 Example 1: XOR Chip
XOR: `A XOR B = (A NAND (A NAND B)) NAND (B NAND (A NAND B))`.

**Truth Table**:
| A | B | A XOR B |
|---|---|---------|
| 0 | 0 |    0    |
| 0 | 1 |    1    |
| 1 | 0 |    1    |
| 1 | 1 |    0    |

**Implementation** (using NAND, chip_location = 1):
- **Step 1**: Compute `T1 = A NAND B` (store in RAM[16]).
- **Step 2**: Compute `T2 = A NAND T1` (store in RAM[17]).
- **Step 3**: Compute `T3 = B NAND T1` (store in RAM[18]).
- **Step 4**: Compute `T4 = T2 NAND T3` (output to tape or RAM).

**Program File** (assuming NAND is chip 1 in `chip_bank.txt`):
```
0000000000000001  # Chip 1 (NAND)
0000000000010000  # Output to RAM[16]
0000000000000101  # Input A: switch_0 (5)
0000000000000110  # Input B: switch_1 (6)

0000000000000001  # Chip 1 (NAND)
0000000000010001  # Output to RAM[17]
0000000000000101  # Input A: switch_0 (5)
0000000000010000  # Input B: RAM[16]

0000000000000001  # Chip 1 (NAND)
0000000000010010  # Output to RAM[18]
0000000000000110  # Input B: switch_1 (6)
0000000000010000  # Input B: RAM[16]

0000000000000001  # Chip 1 (NAND)
0000000000000000  # Output to tape
0000000000010001  # Input A: RAM[17]
0000000000010010  # Input B: RAM[18]
```

**Explanation**:
- Uses `switch_0` (5) and `switch_1` (6) as inputs A and B.
- Stores intermediate results in RAM[16–18].
- Final XOR output goes to `cli_tape.txt`.
- Run with `./emulator program.txt` and flip switches to test (e.g., `1` and `2`).

### ➕ Example 2: 1-Bit Adder
A 1-bit adder computes `Sum = A XOR B` and `Carry = A AND B`. Since AND can be made from NAND (`A AND B = NOT (A NAND B)`), we use NAND instructions.

**Truth Table**:
| A | B | Sum | Carry |
|---|---|-----|-------|
| 0 | 0 |  0  |   0   |
| 0 | 1 |  1  |   0   |
| 1 | 0 |  1  |   0   |
| 1 | 1 |  0  |   1   |

**Implementation**:
- **Sum**: Same as XOR (above).
- **Carry**: `A AND B = NOT (A NAND B)`.
  - Compute `T1 = A NAND B`.
  - Compute `Carry = T1 NAND T1`.

**Program File** (Sum to tape, Carry to RAM[19]):
```
0000000000000001  # Chip 1 (NAND)
0000000000010000  # Output to RAM[16]: T1 = A NAND B
0000000000000101  # Input A: switch_0 (5)
0000000000000110  # Input B: switch_1 (6)

0000000000000001  # Chip 1 (NAND)
0000000000010001  # Output to RAM[17]: T2 = A NAND T1
0000000000000101  # Input A: switch_0 (5)
0000000000010000  # Input B: RAM[16]

0000000000000001  # Chip 1 (NAND)
0000000000010010  # Output to RAM[18]: T3 = B NAND T1
0000000000000110  # Input B: switch_1 (6)
0000000000010000  # Input B: RAM[16]

0000000000000001  # Chip 1 (NAND)
0000000000000000  # Output to tape: Sum = T2 NAND T3
0000000000010001  # Input A: RAM[17]
0000000000010010  # Input B: RAM[18]

0000000000000001  # Chip 1 (NAND)
0000000000010011  # Output to RAM[19]: Carry = T1 NAND T1
0000000000010000  # Input A: RAM[16]
0000000000010000  # Input B: RAM[16]
```

**Explanation**:
- Computes XOR for Sum (as above).
- Computes Carry by NANDing `T1` with itself.
- Sum goes to tape, Carry to RAM[19].
- Test by running and flipping switches.

## 🐛 Known Bugs and Limitations

1. **RAM Clearing on Read** 🧠:
   - Reading RAM (`input > 15`) clears the address, which may disrupt multi-step logic.
   - **Fix**: Add a flag to disable clearing or use separate read-only memory. 🚩️(hold and re-write)👨🏽‍🚀️
   {first validate wtf there talking about}

2. **File I/O Errors** 📁:
   - Failure to open `ram_output_address.txt` or `cli_tape.txt` causes crashes or skips.
   - **Fix**: Add robust error handling (e.g., check permissions, use temp files).

3. **Input Validation** ⚠️:
   - Non-binary or short program lines cause warnings but don’t halt, leading to undefined behavior.
   - **Fix**: Strictly validate program file format and exit on errors.

4. **Single-Bit Limitation** 🔢:
   - Instructions handle 1-bit inputs/outputs, making multi-bit operations (e.g., 8-bit adder) cumbersome.
   - **Fix**: Allow multi-bit inputs via new input codes or chip interface.

5. **Sequential Execution** ⏱️:
   - Instructions run sequentially per cycle, not modeling parallel hardware.
   - **Fix**: Simulate parallel execution or add pipeline support.

## 🔧 Suggested Modifications

1. **Better Error Handling** 🛡️:
   - Log errors to `error.log`.
   - Check file existence and permissions before operations.

2. **Extended Inputs** 🔌:
   - Add input codes for multi-bit values or persistent RAM reads.

3. **Program Preprocessor** 📝:
   - Convert human-readable HDL (e.g., `NAND 5 6 -> 16`) to 16-bit binary.

4. **Debug Mode** 🔍:
   - Trace RAM, tape, and chip states per cycle.
   - Add breakpoints for specific cycles.

5. **Web Interface** 🖥️:
   - Create an HTML/JS GUI to visualize circuits and edit programs.

## 📝 Example Analysis

The provided `program]a0]PROOF.txt` has five instructions, producing tape output `1, 1, 0, ...`. Example:
```
0000000000000001  # NAND chip
0000000000010000  # Output to RAM[16]
0000000000000011  # Input A: blank (3)
0000000000010000  # Input B: RAM[16]
```
- If Input A is blank, the emulator expects chip_location = 0 for pass-through, so this may error unless chip_location = 0.
- Output suggests NAND and pass-through logic, but exact behavior depends on `chip_bank.txt`.

## 🚀 Getting Started

1. **Setup**:
   - Compile: `gcc -o emulator 0.hdlb0.☮️]a3]2]PURE.c`.
   - Create `chip_bank.txt` with `nand`.
   - Write a program file in 16-bit binary (use XOR/Adder examples).

2. **Run**:
   - `./emulator program.txt`
   - Use `s`, `r`, `1`, `2`, or `q` to control.

3. **Create Chips**:
   - Combine NAND instructions in the program file to build XOR, Adder, etc.
   - Test with switches and check tape/RAM outputs.

## 🎯 Conclusion

HDLb0 lets you simulate digital circuits using 16-bit binary instructions! 🌐 By mastering NAND-based designs, you can create XOR, adders, and more. Fix bugs and add features to enhance this emulator. Happy circuit building! 💪😄
